角色设定 (Persona):
你是一位顶级的国家首席图形程序员和着色器逆向工程专家。你精通HLSL、渲染管线以及编译器如何将高级着色器代码转换为汇编指令。你的核心能力是精确分析和复现复杂的着色器逻辑。
任务指令 (Your Task):
仔细分析下面提供的所有代码（A, B）。
A是重命名后的结果 B是正确源码编译结果
识别出代码A中所有与代码B不一致的逻辑错误 特别是分量 重构后的分量被当作单独定义导致大量逻辑错误 你需要仔细分析分量生命周期来修复。
禁止省略任何代码。请为我提供一份完整、准确、可以直接编译的、已修复的代码A。
这份修复后的代码必须严格遵循代码D的逻辑流程，目标是实现与B源码的编译等价性,不能使用unroll 不能添加注释 不能把A的代码直接替换为B的代码或命名来解决问题。

A:float4 frag (VertexToFragment fragmentInput) : SV_Target
{
    float4 v0 = fragmentInput.uv;

    float4 color = 0;
    
    float4 r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,r16;
    uint4 bitmask, uiDest;
    float4 fDest;

    float4 gbufferA_Swizzled = tex2Dlod(_IN1, float4(fragmentInput.uv.xy, 0, 0)).wxyz;
    float perObjectData = gbufferA_Swizzled.x;
    float4 materialProperties = tex2Dlod(_IN2, float4(fragmentInput.uv.xy, 0, 0)).xyzw;
    float3 albedo = tex2Dlod(_IN3, float4(fragmentInput.uv.xy, 0, 0)).xyz;
    float3 gbufferD_Swizzled = tex2Dlod(_IN4, float4(fragmentInput.uv.xy, 0, 0)).yxz;
    float sceneDepth = tex2Dlod(_IN0, float4(fragmentInput.uv.xy, 0, 0)).x;
    float viewZ_ParamA = sceneDepth * cb1[65].x + cb1[65].y;
    float viewZ_ParamB = sceneDepth * cb1[65].z + -cb1[65].w;
    float rcp_viewZ_ParamB = 1.0f / viewZ_ParamB;
    float viewZ = viewZ_ParamA + rcp_viewZ_ParamB;
    float2 screenPixelCoordF = cb1[138].xy * fragmentInput.uv.xy;
    uint2 screenPixelCoord = (uint2)screenPixelCoordF;
    uint ditherPatternSeed = (uint)cb1[158].x;
    int ditherPatternBase = (int)screenPixelCoord.y + (int)screenPixelCoord.x;
    int ditherPatternCombined = (int)ditherPatternSeed + (int)ditherPatternBase;
    int ditherResult = (int)ditherPatternCombined & 1;
    float shadingModelID_f = 255.0f * materialProperties.w;
    float shadingModelID_rounded = round(shadingModelID_f);
    uint shadingModelID = (uint)shadingModelID_rounded;
    int2 shadingModelFlags = (int2)shadingModelID.xx & int2(15,-16);
    float isNotClearCoat = ((int)shadingModelFlags.x != 12) ? 1.0f : 0.0f;
    float3 isAnisotropicOrCloth = ((int3)shadingModelFlags.xxx == int3(13,14,15)) ? 1.0f : 0.0f;
    int isClothOrAnisotropic = (int)isAnisotropicOrCloth.z | (int)isAnisotropicOrCloth.y;
    int isSpecialShadingModel = (int)isClothOrAnisotropic | (int)isAnisotropicOrCloth.x;
    float specialShadingPathFlag = isNotClearCoat ? (float)isSpecialShadingModel : -1.0f;
    
    float3 worldNormal;
    float3 materialPropertiesSq;
    float3 specialPathData;

    if (specialShadingPathFlag != 0.0f) {
        float simplifiedShadingModel = isAnisotropicOrCloth.x ? 13.0f : 12.0f;
        float2 anisotropicFlags = isAnisotropicOrCloth.yz ? float2(1.0f,1.0f) : float2(0.0f,0.0f);
        specialPathData.xz = anisotropicFlags;
        float2 normalOctahedronEncoded = gbufferA_Swizzled.yz * float2(2.0f,2.0f) + float2(-1.0f,-1.0f);
        float normalOctahedronL1 = dot(float2(1.0f,1.0f), abs(normalOctahedronEncoded));
        float decodedNormalZ = 1.0f + -normalOctahedronL1;
        float normalDecodeFactor = max(0.0f, -decodedNormalZ);
        float2 normalDecodeSign = (normalOctahedronEncoded >= float2(0.0f,0.0f)) ? 1.0f : 0.0f;
        float2 normalDecodeSignRemapped = normalDecodeSign ? float2(0.5f,0.5f) : float2(-0.5f,-0.5f);
        float2 normalDecodeOffset = normalDecodeSignRemapped * normalDecodeFactor.xx;
        float2 decodedNormalXY = normalDecodeOffset * float2(-2.0f,-2.0f) + normalOctahedronEncoded;
        float decodedNormalLengthSq = dot(float3(decodedNormalXY, decodedNormalZ), float3(decodedNormalXY, decodedNormalZ));
        float rcpDecodedNormalLength = rsqrt(decodedNormalLengthSq);
        worldNormal = float3(decodedNormalXY, decodedNormalZ) * rcpDecodedNormalLength.xxx;
        materialPropertiesSq = materialProperties.xyz * materialProperties.xyz;
        specialPathData.y = gbufferD_Swizzled.z;
    } else {
        float isDecal = ((int)shadingModelFlags.x == 10) ? 1.0f : 0.0f;
        float3 materialPropertiesSat = saturate(materialProperties.xyz);
        float3 materialPropertiesPackedF = float3(16777215.0f,65535.0f,255.0f) * materialPropertiesSat;
        float3 materialPropertiesPackedRound = round(materialPropertiesPackedF);
        uint3 materialPropertiesPackedU = (uint3)materialPropertiesPackedRound;
        bitmask.y = ((~(-1 << 8)) << 0) & 0xffffffff;  uint packedRoughnessInSpecular = (((uint)materialPropertiesPackedU.z << 0) & bitmask.y) | ((uint)materialPropertiesPackedU.y & ~bitmask.y);
        bitmask.x = ((~(-1 << 16)) << 0) & 0xffffffff;  uint packedAllInMetallic = (((uint)packedRoughnessInSpecular << 0) & bitmask.x) | ((uint)materialPropertiesPackedU.x & ~bitmask.x);
        uint finalPackedMaterial = (uint)packedAllInMetallic;
        float unpackedDepthFromMaterial = 5.96046519e-008f * (float)finalPackedMaterial;
        float unpackedViewZ_ParamA = unpackedDepthFromMaterial * cb1[65].x + cb1[65].y;
        float unpackedViewZ_ParamB = unpackedDepthFromMaterial * cb1[65].z + -cb1[65].w;
        float rcp_unpackedViewZ_ParamB = 1.0f / unpackedViewZ_ParamB;
        float unpackedViewZ = unpackedViewZ_ParamA + rcp_unpackedViewZ_ParamB;
        viewZ = isDecal ? unpackedViewZ : viewZ;
        worldNormal = gbufferA_Swizzled.yzw * float3(2.0f,2.0f,2.0f) + float3(-1.0f,-1.0f,-1.0f);
        materialPropertiesSq = float3(0.0f,0.0f,0.0f);
        specialPathData = float3(0.0f,0.0f,0.0f);
        gbufferA_Swizzled.xw = float2(0.0f,0.0f);
        gbufferD_Swizzled.xy = float2(0.0f,0.0f);
    }
    float worldNormalLengthSq = dot(worldNormal, worldNormal);
    float rcpWorldNormalLength = rsqrt(worldNormalLengthSq);
    float3 normalizedWorldNormal = worldNormal * rcpWorldNormalLength.xxx;
    float2 shadingModelCheckFlags = ((int2)shadingModelFlags.xx == int2(5,13)) ? 1.0f : 0.0f;
    float useImaginaryLight = (0.0f < cb1[162].y) ? 1.0f : 0.0f;
    float useAO = (0.0f < cb1[220].z) ? 1.0f : 0.0f;
    useImaginaryLight = useImaginaryLight ? useAO : 0.0f;
    float isImaginaryLightEnabled = (0 != cb1[162].y) ? 1.0f : 0.0f;
    float3 baseColor = isImaginaryLightEnabled ? float3(1.0f,1.0f,1.0f) : albedo;
    ditherResult = ditherResult ? 1 : 0;
    baseColor = useImaginaryLight ? (float3)ditherResult : baseColor;
    albedo = (rcpWorldNormalLength != 0.0f) ? baseColor : albedo;
    float eyeAdaptation = tex2Dlod(_IN9, float4(0, 0, 0, 0)).x;
    float2 worldPosXY = fragmentInput.uv.zw * viewZ.xx;
    float3 viewSpacePosition = cb1[49].xyz * worldPosXY.yyy;
    viewSpacePosition = worldPosXY.xxx * cb1[48].xyz + viewSpacePosition;
    viewSpacePosition = viewZ.xxx * cb1[50].xyz + viewSpacePosition;
    viewSpacePosition = cb1[51].xyz + viewSpacePosition;
    float2 shadowTerms = tex2Dlod(_IN5, float4(fragmentInput.uv.xy, 0, 0)).xz;
    float2 shadowTermsSq = shadowTerms * shadowTerms;
    float shadowTerm = shadowTermsSq.x * shadowTermsSq.y;
    float shadowStrength = cb1[253].y * shadowTerm;
    float3 bentNormal;
    float finalShadowFactor;
    float3 fresnelTerm1;

    if (cb1[255].x != 0.0f) {
        float3 bentNormalAccum = float3(0.0f,0.0f,0.0f);
        float2 aoLoopControls = float2(0.0f,0.0f);
        float aoSampleStep = 0.0f;
        float totalWeight = 0.0f;
        while (true) {
        float isOuterLoopDone = ((int)aoLoopControls.x >= 3) ? 1.0f : 0.0f;
        if (isOuterLoopDone != 0.0f) break;
        aoLoopControls.y = 0.000833333295f + aoLoopControls.y;
        float3 innerBentNormalAccum = bentNormalAccum;
        float currentAngleStep = aoSampleStep;
        float innerTotalWeight = totalWeight;
        int innerLoopCounter = 0;
        while (true) {
            float isInnerLoopDone = ((int)innerLoopCounter >= 3) ? 1.0f : 0.0f;
            if (isInnerLoopDone != 0.0f) break;
            currentAngleStep = 1.0f + currentAngleStep;
            float sampleAngle = 2.09439516f * currentAngleStep;
            float sampleSin, sampleCos;
            sincos(sampleAngle, sampleSin, sampleCos);
            float sampleU = sampleCos * aoLoopControls.y + fragmentInput.uv.x;
            float sampleV = sampleSin * aoLoopControls.y + fragmentInput.uv.y;
            float3 aoSample = tex2D(_IN7, float2(sampleU, sampleV)).xyz;
            innerBentNormalAccum = aoSample * aoLoopControls.yyy + innerBentNormalAccum;
            innerTotalWeight = innerTotalWeight + aoLoopControls.y;
            innerLoopCounter = (int)innerLoopCounter + 1;
        }
        bentNormalAccum = innerBentNormalAccum;
        totalWeight = innerTotalWeight;
        aoSampleStep = 0.620000005f + currentAngleStep;
        aoLoopControls.x = (int)aoLoopControls.x + 1;
        }
        float3 bentNormalFromAO = bentNormalAccum / totalWeight.xxx;
        float3 colorRangeChecks_1 = (gbufferA_Swizzled.xxx > float3(0.644999981f,0.312000006f,0.978999972f)) ? 1.0f : 0.0f;
        float3 colorRangeChecks_2 = (gbufferA_Swizzled.xxx < float3(0.685000002f,0.351999998f,1.02100003f)) ? 1.0f : 0.0f;
        float3 inColorRange = colorRangeChecks_1 * colorRangeChecks_2;
        float colorSelect = inColorRange.z ? 1.000000f : 0.0f;
        colorSelect = inColorRange.y ? 0.0f : colorSelect;
        colorSelect = inColorRange.x ? 1.0f : colorSelect;
        int colorRangeMask = (int)inColorRange.y | (int)inColorRange.z;
        int temp_colorRangeFlag = colorRangeMask & 0x3f800000;
        float colorRangeFlag = inColorRange.x ? 0.0f : (float)temp_colorRangeFlag;
        float gbufferD_X_f = 255.0f * gbufferD_Swizzled.x;
        float gbufferD_X_rounded = round(gbufferD_X_f);
        uint gbufferD_X_u = (uint)gbufferD_X_rounded;
        int4 gbufferD_X_bits = (int4)gbufferD_X_u.xxxx & int4(15,240,240,15);
        uint4 gbufferD_X_bitflags = (uint4)gbufferD_X_bits;
        float smoothnessA = saturate(perObjectData + perObjectData);
        float smoothnessFactorA = smoothnessA * -2.0f + 3.0f;
        smoothnessA = smoothnessA * smoothnessA;
        smoothnessA = smoothnessFactorA * smoothnessA;
        float smoothnessB = -0.5f + perObjectData;
        smoothnessB = saturate(smoothnessB + smoothnessB);
        float smoothnessFactorB = smoothnessB * -2.0f + 3.0f;
        smoothnessB = smoothnessB * smoothnessB;
        smoothnessB = smoothnessFactorB * smoothnessB;
        float3 colorDiff = cb1[262].xyz + -cb1[261].xyz;
        float colorDiffLuma = dot(abs(colorDiff), float3(0.300000012f,0.589999974f,0.109999999f));
        float colorDiffFactor = 10.0f * colorDiffLuma;
        colorDiffFactor = min(1.0f, colorDiffFactor);
        float colorDiffRemap = colorDiffFactor * -2.0f + 3.0f;
        colorDiffFactor = colorDiffFactor * colorDiffFactor;
        colorDiffFactor = colorDiffRemap * colorDiffFactor;
        float smoothnessTerm = colorDiffFactor * smoothnessB;
        float shadowRange = cb1[265].y + -cb1[265].x;
        float shadowPos = shadowTerm * cb1[253].y + -cb1[265].x;
        float rcpShadowRange = 1.0f / shadowRange;
        float shadowLerp = saturate(shadowPos * rcpShadowRange);
        float shadowFactorRemap = shadowLerp * -2.0f + 3.0f;
        shadowLerp = shadowLerp * shadowLerp;
        shadowLerp = shadowFactorRemap * shadowLerp;
        shadowLerp = shadowLerp * smoothnessTerm;
        float shadowPosRemapped = shadowTerm * cb1[253].y + -shadowLerp;
        shadowLerp = cb1[265].z * shadowPosRemapped + shadowLerp;
        float shadowFinalPos = -cb1[265].x + shadowLerp;
        float shadowFinalLerp = saturate(shadowFinalPos * rcpShadowRange);
        float shadowFinalFactorRemap = shadowFinalLerp * -2.0f + 3.0f;
        shadowFinalLerp = shadowFinalLerp * shadowFinalLerp;
        shadowFinalLerp = shadowFinalFactorRemap * shadowFinalLerp;
        smoothnessTerm = shadowFinalLerp * smoothnessTerm;
        smoothnessB = smoothnessB * colorDiffFactor + -smoothnessTerm;
        smoothnessB = cb1[265].z * smoothnessB + smoothnessTerm;
        float shadowStrengthMod = -1.0f + shadowLerp;
        shadowStrengthMod = cb1[260].y * shadowStrengthMod + 1.0f;
        float finalSmoothnessA = ditherResult * smoothnessB + -shadowStrengthMod;
        float updatedShadowStrengthMod = isAnisotropicOrCloth.x * finalSmoothnessA + shadowStrengthMod;
        float finalSmoothnessB = ditherResult * smoothnessB + -smoothnessB;
        finalShadowFactor = isAnisotropicOrCloth.x * finalSmoothnessB + smoothnessB;
        float hueCheck = (bentNormalFromAO.y >= bentNormalFromAO.z) ? 1.0f : 0.0f;
        hueCheck = hueCheck ? 1.000000f : 0.0f;
        float2 hueVec1_xy = bentNormalFromAO.zy;
        float2 hueVec1_zw = float2(-1.0f,0.666666687f);
        float2 hueVec2_xy = -hueVec1_xy + bentNormalFromAO.yz;
        float2 hueVec2_zw = float2(1.0f,-1.0f);
        float4 hueVec1 = hueCheck.xxxx * float4(hueVec2_xy, hueVec2_zw) + float4(hueVec1_xy, hueVec1_zw);
        float hueCheck2 = (bentNormalFromAO.x >= hueVec1.x) ? 1.0f : 0.0f;
        hueCheck2 = hueCheck2 ? 1.000000f : 0.0f;
        float3 hueVec3_xyz = hueVec1.xyw;
        float hueVec3_w = bentNormalFromAO.x;
        float3 hueVec4_xyw = float3(hueVec3_w,hueVec3_xyz.yx);
        float4 hueVec3 = float4(hueVec3_xyz.x, hueVec3_xyz.y, hueVec3_xyz.z, hueVec3_w);
        float4 hueVec4 = float4(hueVec4_xyw.x, hueVec4_xyw.y, hueVec3_w, hueVec4_xyw.z) + -hueVec3;
        hueVec3 = hueCheck2.xxxx * hueVec4 + hueVec3;
        float hueSaturation = min(hueVec3.w, hueVec3.y);
        hueSaturation = hueVec3.x + -hueSaturation;
        float hueValue = hueVec3.w + -hueVec3.y;
        float hueDivisor = hueSaturation * 6.0f + 0.00100000005f;
        hueValue = hueValue / hueDivisor;
        hueValue = hueVec3.z + hueValue;
        float hueSaturationDivisor = 0.00100000005f + hueVec3.x;
        hueSaturation = hueSaturation / hueSaturationDivisor;
        float hueBrightness = hueVec3.x * 0.300000012f + 1.0f;
        float4 tintFactors = gbufferD_X_bitflags * float4(0.0400000028f,0.0027450982f,0.00392156886f,0.0666666701f) + float4(0.400000006f,0.400000006f,1.0f,0.5f);
        float tintCheck = (gbufferD_X_bitflags.z >= 2.54999971f) ? 1.0f : 0.0f;
        tintCheck = tintCheck ? 1.000000f : 0.0f;
        float tintFactor = tintFactors.y + -tintFactors.x;
        tintFactor = tintCheck * tintFactor + tintFactors.x;
        hueSaturation = tintFactor * hueSaturation;
        hueSaturation = min(0.349999994f, hueSaturation);
        float finalSaturation = max(0.0f, hueSaturation);
        float3 hueRemapFactors = float3(1.0f,0.666666687f,0.333333343f) + abs(hueValue.xxx);
        hueRemapFactors = frac(hueRemapFactors);
        hueRemapFactors = hueRemapFactors * float3(6.0f,6.0f,6.0f) + float3(-3.0f,-3.0f,-3.0f);
        hueRemapFactors = saturate(float3(-1.0f,-1.0f,-1.0f) + abs(hueRemapFactors));
        hueRemapFactors = float3(-1.0f,-1.0f,-1.0f) + hueRemapFactors;
        float3 hueColor = finalSaturation.xxx * hueRemapFactors + float3(1.0f,1.0f,1.0f);
        float saturationBrightness = 1.0f + hueSaturation;
        float3 color1 = hueColor * saturationBrightness.xxx;
        float3 color2 = hueColor * saturationBrightness.xxx + float3(-1.0f,-1.0f,-1.0f);
        color2 = color2 * float3(0.600000024f,0.600000024f,0.600000024f) + float3(1.0f,1.0f,1.0f);
        float3 finalHueColor = gbufferA_Swizzled.xxx * (color2 + -color1) + color1;
        finalHueColor = finalHueColor + -albedo;
        finalHueColor = finalHueColor * float3(0.850000024f,0.850000024f,0.850000024f) + albedo;
        float3 colorBlendFactor = tintFactors.zzz * finalHueColor + -albedo;
        finalHueColor = tintCheck.xxx * colorBlendFactor + albedo;
        finalHueColor = float3(-1.0f,-1.0f,-1.0f) + finalHueColor;
        finalHueColor = tintFactors.www * finalHueColor + float3(1.0f,1.0f,1.0f);
        float3 indirectDiffuse_Base = float3(0.200000003f,0.200000003f,0.200000003f) * cb1[261].xyz;
        float3 indirectDiffuse_Range = cb1[262].xyz * float3(0.5f,0.5f,0.5f) + -indirectDiffuse_Base;
        float3 indirectDiffuse_Lerped = updatedShadowStrengthMod.xxx * indirectDiffuse_Range + indirectDiffuse_Base;
        indirectDiffuse_Lerped = cb1[260].xxx * indirectDiffuse_Lerped;
        indirectDiffuse_Lerped = indirectDiffuse_Lerped * albedo;
        float3 indirectSpecular_Base = indirectDiffuse_Lerped * materialPropertiesSq;
        float3 fresnelBase = cb1[261].xyz * albedo;
        float smoothnessTerm_gD = gbufferD_X_u * 0.300000012f + 0.699999988f;
        fresnelTerm1 = fresnelBase * smoothnessTerm_gD.xxx;
        float3 fresnelTerm2 = cb1[262].xyz * albedo;
        indirectSpecular_Base = fresnelBase * smoothnessTerm_gD.xxx + indirectSpecular_Base;
        fresnelBase = albedo * cb1[262].xyz + -fresnelTerm1;
        fresnelBase = fresnelBase * float3(0.400000006f,0.400000006f,0.400000006f) + fresnelTerm1;
        float3 specularTerm1 = fresnelTerm1 * finalHueColor;
        fresnelBase = fresnelBase * finalHueColor + -specularTerm1;
        fresnelBase = finalShadowFactor.xxx * fresnelBase + specularTerm1;
        indirectDiffuse_Lerped = indirectDiffuse_Lerped * materialPropertiesSq + fresnelBase;
        indirectSpecular_Base = indirectSpecular_Base * finalHueColor;
        fresnelTerm1 = fresnelTerm2 * hueBrightness.xxx;
        float3 finalColorTemp = fresnelTerm1 * finalHueColor + -indirectSpecular_Base;
        finalColorTemp = finalShadowFactor.xxx * finalColorTemp + indirectSpecular_Base;
        float screenSpaceAO = tex2Dlod(_IN8, float4(fragmentInput.uv.xy, 0, 0)).x;
        screenSpaceAO = -1.0f + screenSpaceAO;
        screenSpaceAO = colorRangeFlag * screenSpaceAO + 1.0f;
        finalColorTemp = finalColorTemp + -indirectDiffuse_Lerped;
        finalColorTemp = updatedShadowStrengthMod.xxx * finalColorTemp + indirectDiffuse_Lerped;
        float3 aoFactor = float3(1.0f,1.0f,1.0f) + -bentNormalFromAO;
        bentNormalFromAO = screenSpaceAO.xxx * aoFactor + bentNormalFromAO;
        bentNormal = finalColorTemp * bentNormalFromAO;
    } else {
        float smoothnessA = saturate(perObjectData + perObjectData);
        float smoothnessFactorA = smoothnessA * -2.0f + 3.0f;
        smoothnessA = smoothnessA * smoothnessA;
        smoothnessA = smoothnessFactorA * smoothnessA;
        float smoothnessB = -0.5f + perObjectData;
        smoothnessB = saturate(smoothnessB + smoothnessB);
        float smoothnessFactorB = smoothnessB * -2.0f + 3.0f;
        smoothnessB = smoothnessB * smoothnessB;
        smoothnessB = smoothnessFactorB * smoothnessB;
        float3 colorDiff = cb1[262].xyz + -cb1[261].xyz;
        float colorDiffLuma = dot(abs(colorDiff), float3(0.300000012f,0.589999974f,0.109999999f));
        colorDiffLuma = 10.0f * colorDiffLuma;
        colorDiffLuma = min(1.0f, colorDiffLuma);
        float colorDiffRemap = colorDiffLuma * -2.0f + 3.0f;
        colorDiffLuma = colorDiffLuma * colorDiffLuma;
        colorDiffLuma = colorDiffRemap * colorDiffLuma;
        float smoothnessTerm = colorDiffLuma * smoothnessB;
        float shadowRange = cb1[265].y + -cb1[265].x;
        float shadowPos = shadowTerm * cb1[253].y + -cb1[265].x;
        float rcpShadowRange = 1.0f / shadowRange;
        float shadowLerp = saturate(shadowPos * rcpShadowRange);
        float shadowFactorRemap = shadowLerp * -2.0f + 3.0f;
        shadowLerp = shadowLerp * shadowLerp;
        shadowLerp = shadowFactorRemap * shadowLerp;
        shadowLerp = shadowLerp * smoothnessTerm;
        float shadowTermUpdated = shadowTerm * cb1[253].y + -shadowLerp;
        shadowTermUpdated = cb1[265].z * shadowTermUpdated + shadowLerp;
        float shadowLerpUpdated = -cb1[265].x + shadowTermUpdated;
        float rcpShadowRangeSaturated = saturate(shadowLerpUpdated * rcpShadowRange);
        shadowLerp = rcpShadowRangeSaturated * -2.0f + 3.0f;
        rcpShadowRangeSaturated = rcpShadowRangeSaturated * rcpShadowRangeSaturated;
        rcpShadowRangeSaturated = shadowLerp * rcpShadowRangeSaturated;
        smoothnessTerm = rcpShadowRangeSaturated * smoothnessTerm;
        smoothnessB = smoothnessB * colorDiffLuma + -smoothnessTerm;
        smoothnessB = cb1[265].z * smoothnessB + smoothnessTerm;
        float unknownFactor = shadowTermUpdated * specialPathData.y;
        unknownFactor = 10.0f * unknownFactor;
        float shadowStrengthMod = -1.0f + shadowTermUpdated;
        shadowStrengthMod = cb1[260].y * shadowStrengthMod + 1.0f;
        float finalSmoothnessA = ditherResult * smoothnessB + -shadowStrengthMod;
        shadowStrengthMod = isAnisotropicOrCloth.x * finalSmoothnessA + shadowStrengthMod;
        float finalSmoothnessB = ditherResult * smoothnessB + -smoothnessB;
        finalShadowFactor = isAnisotropicOrCloth.x * finalSmoothnessB + smoothnessB;
        float3 indirectDiffuse_Base = float3(0.200000003f,0.200000003f,0.200000003f) * cb1[261].xyz;
        float3 indirectDiffuse_Range = cb1[262].xyz * float3(0.5f,0.5f,0.5f) + -indirectDiffuse_Base;
        indirectDiffuse_Base = shadowStrengthMod.xxx * indirectDiffuse_Range + indirectDiffuse_Base;
        indirectDiffuse_Base = cb1[260].xxx * indirectDiffuse_Base;
        indirectDiffuse_Base = indirectDiffuse_Base * albedo;
        float3 indirectSpecular_Base = indirectDiffuse_Base * materialPropertiesSq;
        float3 fresnelBase_temp = cb1[261].xyz * albedo;
        float smoothnessTerm_A = smoothnessA * 0.300000012f + 0.699999988f;
        fresnelTerm1 = fresnelBase_temp * smoothnessTerm_A.xxx;
        float3 fresnelBase_new = fresnelBase_temp * smoothnessTerm_A.xxx + indirectSpecular_Base;
        float3 indirectSpecular_Base_new = indirectSpecular_Base * unknownFactor.xxx + fresnelBase_new;
        float3 fresnelBase_recalc = albedo * cb1[262].xyz + -fresnelTerm1;
        fresnelBase_recalc = fresnelBase_recalc * finalShadowFactor.xxx;
        fresnelBase_recalc = fresnelBase_recalc * float3(0.400000006f,0.400000006f,0.400000006f) + fresnelTerm1;
        indirectDiffuse_Base = indirectDiffuse_Base * materialPropertiesSq + fresnelBase_recalc;
        float3 specular_final_term = albedo * cb1[262].xyz + -indirectSpecular_Base_new;
        specular_final_term = finalShadowFactor.xxx * specular_final_term + indirectSpecular_Base_new;
        specular_final_term = specular_final_term + -indirectDiffuse_Base;
        bentNormal = shadowStrengthMod.xxx * specular_final_term + indirectDiffuse_Base;
    }
    float perObjectDataFactor = -0.400000006f + perObjectData;
    perObjectDataFactor = saturate(10.000001f * perObjectDataFactor);
    float perObjectDataRemap = perObjectDataFactor * -2.0f + 3.0f;
    perObjectDataFactor = perObjectDataFactor * perObjectDataFactor;
    float finalSmoothnessFactor = perObjectDataRemap * perObjectDataFactor;
    float3 finalColorTerm1 = bentNormal * float3(0.5f,0.5f,0.5f) + cb1[261].xyz;
    finalColorTerm1 = finalColorTerm1 * albedo;
    float3 finalColorTerm2_base = cb1[261].xyz * albedo;
    finalColorTerm1 = (cb1[255].x != 0.0f) ? finalColorTerm1 : finalColorTerm2_base;
    float3 finalColorTerm2 = (eyeAdaptation != 0.0f) ? finalColorTerm1 : fresnelTerm1;
    finalColorTerm1 = (eyeAdaptation != 0.0f) ? finalColorTerm1 : bentNormal;
    float2 finalBlendFactors = (eyeAdaptation != 0.0f) ? float2(0.0f,0.0f) : float2(finalShadowFactor, finalSmoothnessFactor);
    float3 lightBleedControl = cb1[264].xyz + cb1[264].xyz;
    float screenSpaceAO = tex2Dlod(_IN8, float4(fragmentInput.uv.xy, 0, 0)).x;
    lightBleedControl = screenSpaceAO.xxx * lightBleedControl + -cb1[264].xyz;
    float3 localLightsAccum = float3(0.0f,0.0f,0.0f);
    float lightAccumulatorWeight = 1.0f;
    uint lightLoopCounter = 0;
    while (true) {
        float isLightLoopDone = ((uint)lightLoopCounter >= asuint(cb2[128].x)) ? 1.0f : 0.0f;
        if (isLightLoopDone != 0.0f) break;
        uint lightDataIndex = (lightLoopCounter * 8) + 7;
        uint lightGroupMask = (asuint(cb2[lightDataIndex].w) >> 5) & 0x1F;
        uint lightActiveCheck = (int)shadingModelFlags.y & (int)lightGroupMask;
        if (lightActiveCheck == 0) {
            lightLoopCounter = (int)lightLoopCounter + 1;
            continue;
        }
        uint lightBaseIndex = (uint)lightLoopCounter << 3;
        float3 lightVector = cb2[lightBaseIndex+0].xyz + -viewSpacePosition;
        float lightInvRadiusSq = cb2[lightBaseIndex+0].w * cb2[lightBaseIndex+0].w;
        float distToLightSq = dot(lightVector, lightVector);
        float attenuation = distToLightSq * lightInvRadiusSq;
        float inLightRange = (1.0f >= attenuation) ? 1.0f : 0.0f;
        if (inLightRange != 0.0f) {
            uint lightDataIndex1 = lightBaseIndex + 1;
            uint lightDataIndex2 = lightBaseIndex + 2;
            uint lightDataIndex3 = lightBaseIndex + 3;
            uint lightDataIndex4 = lightBaseIndex + 4;
            uint lightDataIndex5 = lightBaseIndex + 5;
            uint lightDataIndex6 = lightBaseIndex + 6;
            attenuation = saturate(attenuation * 2.5f + -1.5f);
            float attenuationSq = attenuation * attenuation;
            float attenuationRemap = -attenuation * 2.0f + 3.0f;
            attenuation = -attenuationSq * attenuationRemap + 1.0f;
            float rcpDistToLight = rsqrt(distToLightSq);
            float3 lightDir = lightVector * rcpDistToLight.xxx;
            float NdotL = dot(normalizedWorldNormal, lightDir);
            NdotL = 1.0f + NdotL;
            float2 lightConeParams = cb2[lightDataIndex5+0].ww * float2(0.939999998f,0.0600000024f);
            NdotL = NdotL * 0.5f + -lightConeParams.x;
            float rcpLightConeRange = 1.0f / lightConeParams.y;
            NdotL = saturate(rcpLightConeRange * NdotL);
            float NdotL_remap = NdotL * -2.0f + 3.0f;
            NdotL = NdotL * NdotL;
            NdotL = NdotL_remap * NdotL;
            NdotL = min(1.0f, NdotL);
            float3 lightColor = cb2[lightDataIndex6+0].xyz * rcpWorldNormalLength.xxx;
            float3 diffuseColor = albedo * cb2[lightDataIndex5+0].xyz + -lightColor;
            diffuseColor = NdotL.xxx * diffuseColor + lightColor;
            diffuseColor = cb2[lightDataIndex].xxx * diffuseColor;
            float3 lightVecScaled = cb2[lightBaseIndex+0].www * lightVector;
            float lightFalloff = dot(lightVecScaled, lightVecScaled);
            lightFalloff = lightFalloff * cb2[lightDataIndex4+0].x + cb2[lightDataIndex4+0].y;
            lightFalloff = 9.99999975e-005f + lightFalloff;
            lightFalloff = 1.0f / lightFalloff;
            lightFalloff = -1.0f + lightFalloff;
            lightFalloff = cb2[lightDataIndex4+0].z * lightFalloff;
            lightFalloff = lightFalloff * lightFalloff;
            lightFalloff = min(1.0f, lightFalloff);
            float isSpotLight = ((asuint(cb2[lightDataIndex1+0].w) >> 16) == 2) ? 1.0f : 0.0f;
            float spotAngle = dot(lightDir, cb2[lightDataIndex1+0].xyz);
            spotAngle = -cb2[lightDataIndex2+0].x + spotAngle;
            spotAngle = saturate(cb2[lightDataIndex2+0].y * spotAngle);
            spotAngle = spotAngle * spotAngle;
            spotAngle = spotAngle * spotAngle;
            spotAngle = spotAngle * lightFalloff;
            lightFalloff = isSpotLight ? spotAngle : lightFalloff;
            float HdotL = dot(lightBleedControl, lightDir);
            HdotL = saturate(HdotL * 0.5f + 0.5f);
            HdotL = perObjectDataRemap * HdotL + -perObjectDataFactor;
            HdotL = cb2[lightDataIndex4+0].w * HdotL + perObjectDataFactor;
            float3 specularColorBase = cb2[lightDataIndex3+0].www * finalColorTerm2;
            float3 specularColorRange = -finalColorTerm2 * cb2[lightDataIndex3+0].www + albedo;
            specularColorBase = HdotL.xxx * specularColorRange + specularColorBase;
            specularColorBase = cb2[lightDataIndex3+0].xyz * specularColorBase;
            float lightProfileSum = cb2[lightDataIndex3+0].x + cb2[lightDataIndex3+0].y;
            lightProfileSum = cb2[lightDataIndex3+0].z + lightProfileSum;
            lightProfileSum = cb2[lightDataIndex].x + lightProfileSum;
            lightProfileSum = saturate(10.0f * lightProfileSum);
            float lightProfileFactor = cb2[lightDataIndex].y * lightProfileSum;
            diffuseColor = diffuseColor * lightFalloff.xxx;
            specularColorBase = specularColorBase * lightFalloff.xxx + diffuseColor;
            attenuation = attenuation + -lightFalloff;
            lightFalloff = cb2[lightDataIndex6+0].w * attenuation + lightFalloff;
            localLightsAccum = specularColorBase * lightAccumulatorWeight.xxx + localLightsAccum;
            lightProfileFactor = -lightFalloff * lightProfileFactor + 1.0f;
            lightAccumulatorWeight = lightProfileFactor * lightAccumulatorWeight;
        }
        lightLoopCounter = (int)lightLoopCounter + 1;
    }
    float3 lightLoopColor = lightAccumulatorWeight.xxx * finalColorTerm1 + localLightsAccum;
    float isHair = ((int)shadingModelFlags.x != 13) ? 1.0f : 0.0f;
    float3 hairPathResult;
    float materialFactor = 0.0f;

    if (isHair != 0.0f) {
        float materialTypeCheck = ((int)shadingModelFlags.x == 1) ? 1.0f : 0.0f;
        float materialType = materialTypeCheck ? gbufferD_Swizzled.z : gbufferD_Swizzled.y;
        float3 viewVector = cb1[67].xyz + -viewSpacePosition;
        float viewVectorLength = dot(viewVector, viewVector);
        viewVectorLength = rsqrt(viewVectorLength);
        viewVector = viewVector * viewVectorLength.xxx;
        materialFactor = saturate(-0.100000001f + materialType);
        float materialTypeSat = saturate(10.0f * materialType);
        float materialParamMix = materialFactor * 2000.0f + 50.0f;
        float materialFactorRemapped = materialFactor + materialFactor;
        float materialTypeRemapped = cb0[0].x * materialTypeSat;
        materialTypeRemapped = materialTypeRemapped * 0.800000012f + materialFactorRemapped;
        float3 worldTangent = cb1[21].xyz * normalizedWorldNormal.yyy;
        worldTangent = normalizedWorldNormal.xxx * cb1[20].xyz + worldTangent;
        worldTangent = normalizedWorldNormal.zzz * cb1[22].xyz + worldTangent;
        float useGlobalLightDir = (0.5f < asfloat(cb0[0].w)) ? 1.0f : 0.0f;
        viewVector = (useGlobalLightDir != 0.0f) ? float3(0.0f,0.0f,0.0f) : viewVector;
        float3 lightDirection;
        lightDirection.xy = (useGlobalLightDir != 0.0f) ? cb0[0].yz : cb1[264].xy;
        lightDirection.z = (useGlobalLightDir != 0.0f) ? 0.5f : cb1[264].z;
        normalizedWorldNormal = (useGlobalLightDir != 0.0f) ? worldTangent : normalizedWorldNormal;
        float LdotT = dot(lightDirection, normalizedWorldNormal);
        float2 specParams = float2(0.200000003f,1.0f) + LdotT.xx;
        LdotT = 5.0f * specParams.x;
        LdotT = saturate(LdotT);
        float specFactor = LdotT * -2.0f + 3.0f;
        LdotT = LdotT * LdotT;
        LdotT = specFactor * LdotT;
        float3 halfVector = lightDirection + viewVector;
        float halfVectorLength = dot(halfVector, halfVector);
        halfVectorLength = rsqrt(halfVectorLength);
        halfVector = halfVector * halfVectorLength.xxx;
        float NdotH = saturate(dot(normalizedWorldNormal, halfVector));
        NdotH = NdotH * NdotH;
        NdotH = NdotH * -0.800000012f + 1.0f;
        NdotH = NdotH * NdotH;
        NdotH = 3.14159274f * NdotH;
        NdotH = 0.200000003f / NdotH;
        NdotH = NdotH * ditherResult;
        float VdotT = dot(lightDirection, viewVector);
        float2 fresnelParams = float2(-0.5f,1.0f) + -VdotT.xx;
        VdotT = saturate(fresnelParams.x + fresnelParams.x);
        float fresnelFactor = VdotT * -2.0f + 3.0f;
        VdotT = VdotT * VdotT;
        VdotT = fresnelFactor * VdotT + 1.0f;
        float TdotV = saturate(dot(viewVector, normalizedWorldNormal));
        TdotV = 0.800000012f + -TdotV;
        TdotV = max(0.0f, TdotV);
        float clearcoatRoughness = max(0.0f, cb1[133].x);
        clearcoatRoughness = min(1.74532926f, clearcoatRoughness);
        float2 roughnessParams = float2(1.5f,0.572957814f) * float2(TdotV, clearcoatRoughness);
        float sceneDepthClamped = max(0.0f, viewZ);
        float2 depthRemap = min(float2(3000.0f,50.0f), sceneDepthClamped.xx);
        depthRemap = float2(3000.0f,50.0f) + -depthRemap;
        depthRemap = float2(0.00033333333f,0.0199999996f) * depthRemap;
        float depthFactor = depthRemap.x * depthRemap.x;
        depthFactor = depthFactor * depthFactor;
        depthFactor = depthFactor * depthFactor + depthRemap.y;
        depthFactor = -1.0f + depthFactor;
        roughnessParams.y = roughnessParams.y * depthFactor + 1.0f;
        depthFactor = 1.0f + -roughnessParams.y;
        roughnessParams.y = materialFactor * depthFactor + roughnessParams.y;
        float fresnelTerm = specParams.y * 0.25f + 0.5f;
        roughnessParams.x = fresnelTerm * roughnessParams.x;
        roughnessParams.x = roughnessParams.x * roughnessParams.y;
        roughnessParams.x = roughnessParams.x * VdotT;
        roughnessParams.x = 0.00999999978f * roughnessParams.x;
        float2 ssrParams = float2(9.99999975e-005f,9.99999975e-005f) + materialProperties.xy;
        float ssrFactor = dot(ssrParams, ssrParams);
        ssrFactor = rsqrt(ssrFactor);
        ssrParams = ssrParams * ssrFactor.xx;
        ssrParams = ssrParams * materialTypeRemapped.xx;
        float ssrResult = ssrParams.y * roughnessParams.x;
        float ssrMix = -0.5f;
        float2 ssrFinalParams = float2(ssrParams.x, ssrResult) * ssrMix.xx;
        float materialTypeFinal = 0.400000006f * fresnelParams.y;
        float specTerm = LdotT * 0.800000012f + 0.200000003f;
        float specLobe = NdotH * LdotT;
        specLobe = 1.5f * specLobe;
        materialTypeFinal = materialTypeFinal * specTerm + specLobe;
        specTerm = ditherResult * 0.5f + 0.5f;
        materialTypeFinal = specTerm * materialTypeFinal;
        float2 ssrUV_offset = fragmentInput.uv.xy * cb1[138].xy + -cb1[134].xy;
        ssrFinalParams = ssrUV_offset * cb1[135].zw + ssrFinalParams;
        ssrFinalParams = ssrFinalParams * cb1[135].xy + cb1[134].xy;
        ssrFinalParams = cb1[138].zw * ssrFinalParams;
        float sceneDepthFar = tex2D(_IN6, ssrFinalParams).x;
        float viewZ_Far_A = sceneDepthFar * cb1[65].x + cb1[65].y;
        sceneDepthFar = sceneDepthFar * cb1[65].z + -cb1[65].w;
        float rcpSceneDepthFar = 1.0f / sceneDepthFar;
        float viewZ_Far = viewZ_Far_A + rcpSceneDepthFar;
        viewZ_Far = viewZ_Far + -viewZ;
        viewZ_Far = max(9.99999975e-005f, viewZ_Far);
        float materialFactorFinal = -materialFactor * 1000.0f + viewZ_Far;
        float rcpMaterialParamMix = 1.0f / materialParamMix;
        materialFactorFinal = saturate(rcpMaterialParamMix * materialFactorFinal);
        float materialParamMixRemapped = materialFactorFinal * -2.0f + 3.0f;
        materialFactorFinal = materialFactorFinal * materialFactorFinal;
        materialFactorFinal = materialParamMixRemapped * materialFactorFinal;
        materialFactorFinal = min(1.0f, materialFactorFinal);
        float skyLuma = dot(cb1[263].xyz, float3(0.300000012f,0.589999974f,0.109999999f));
        float3 skyColorDesaturated = cb1[263].xyz + -skyLuma.xxx;
        float3 skyColor = skyColorDesaturated * float3(0.75f,0.75f,0.75f) + skyLuma.xxx;
        skyColorDesaturated = cb1[263].xyz + -skyColor;
        skyColor = (float)ditherResult.xxx * skyColorDesaturated + skyColor;
        skyColor = skyColor * materialTypeFinal.xxx;
        skyColor = float3(0.100000001f,0.100000001f,0.100000001f) * skyColor;
        float3 colorAdd = float3(1.0f,1.0f,1.0f) + rcpWorldNormalLength.xxx;
        colorAdd = colorAdd * skyColor;
        float3 bloomSource = albedo * float3(1.20000005f,1.20000005f,1.20000005f) + float3(-1.0f,-1.0f,-1.0f);
        bloomSource = saturate(-bloomSource);
        float3 bloomFactor = bloomSource * float3(-2.0f,-2.0f,-2.0f) + float3(3.0f,3.0f,3.0f);
        bloomSource = bloomSource * bloomSource;
        bloomSource = bloomFactor * bloomSource;
        bloomSource = bloomSource * float3(14.0f,14.0f,14.0f) + float3(1.0f,1.0f,1.0f);
        skyColor = bloomSource * skyColor;
        skyColor = skyColor * albedo + -colorAdd;
        skyColor = cb1[260].zzz * skyColor + colorAdd;
        skyColor = skyColor * materialFactorFinal.xxx;
        float fogFactor = -10000.0f + viewZ;
        fogFactor = max(0.0f, fogFactor);
        fogFactor = min(5000.0f, fogFactor);
        fogFactor = 5000.0f + -fogFactor;
        fogFactor = 0.000199999995f * fogFactor;
        skyColor = fogFactor.xxx * skyColor;
        hairPathResult = cb0[1].xyz * skyColor;
    } else {
        hairPathResult = float3(0.0f,0.0f,0.0f);
    }
    float useSubsurface = (0.0f != isAnisotropicOrCloth.z) ? 1.0f : 0.0f;
    float3 subsurfaceColor = lightLoopColor * materialPropertiesSq;
    subsurfaceColor = cb1[263].xyz * subsurfaceColor;
    subsurfaceColor = subsurfaceColor * float3(0.5f,0.5f,0.5f) + -lightLoopColor;
    subsurfaceColor = materialFactor.xxx * subsurfaceColor + lightLoopColor;
    float3 finalColor = useSubsurface ? subsurfaceColor : hairPathResult;
    float3 finalComposite = (shadingModelCheckFlags.y != 0.0f) ? lightLoopColor : finalColor;
    finalComposite = finalComposite / eyeAdaptation;
    finalComposite = min(float3(0.0f,0.0f,0.0f), -finalComposite);
    color.xyz = -finalComposite;
    return color;
}
B:
float4 frag (VertexToFragment fragmentInput) : SV_Target
{
    float4 v0 = fragmentInput.uv; 

    float4 color = 0;
    
    float4 r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,r16;
    uint4 bitmask, uiDest;
    float4 fDest;

    r0.xyzw = tex2Dlod(_IN1, float4(v0.xy, 0, 0)).wxyz;
    r1.xyzw = tex2Dlod(_IN2, float4(v0.xy, 0, 0)).xyzw;
    r2.xyz = tex2Dlod(_IN3, float4(v0.xy, 0, 0)).xyz;
    r3.xyz = tex2Dlod(_IN4, float4(v0.xy, 0, 0)).yxz;
    r2.w = tex2Dlod(_IN0, float4(v0.xy, 0, 0)).x;
    r3.w = r2.w * cb1[65].x + cb1[65].y;
    r2.w = r2.w * cb1[65].z + -cb1[65].w;
    r2.w = 1 / r2.w;
    r2.w = r3.w + r2.w;
    r4.xy = cb1[138].xy * v0.xy;
    r4.xy = (uint2)r4.xy;
    r3.w = (uint)cb1[158].x;
    r4.x = (int)r4.y + (int)r4.x;
    r3.w = (int)r3.w + (int)r4.x;
    r3.w = (int)r3.w & 1;
    r1.w = 255 * r1.w;
    r1.w = round(r1.w);
    r1.w = (uint)r1.w;
    r4.xy = (int2)r1.ww & int2(15,-16);
    r1.w = ((int)r4.x != 12) ? 1.0 : 0.0;
    r5.xyz = ((int3)r4.xxx == int3(13,14,15)) ? 1.0 : 0.0;
    r4.z = (int)r5.z | (int)r5.y;
    r4.z = (int)r4.z | (int)r5.x;
    r1.w = r1.w ? r4.z : -1;
    if (r1.w != 0) {
        r4.x = r5.x ? 13 : 12;
        r5.xz = r5.yz ? float2(1,1) : 0;
        r4.zw = r0.yz * float2(2,2) + float2(-1,-1);
        r1.w = dot(float2(1,1), abs(r4.zw));
        r6.z = 1 + -r1.w;
        r1.w = max(0, -r6.z);
        r7.xy = (r4.zw >= float2(0,0)) ? 1.0 : 0.0;
        r7.xy = r7.xy ? float2(0.5,0.5) : float2(-0.5,-0.5);
        r7.xy = r7.xy * r1.ww;
        r6.xy = r7.xy * float2(-2,-2) + r4.zw;
        r1.w = dot(r6.xyz, r6.xyz);
        r1.w = rsqrt(r1.w);
        r6.xyz = r6.xyz * r1.www;
        r7.xyz = r1.xyz * r1.xyz;
        r5.y = r3.z;
    } else {
        r1.w = ((int)r4.x == 10) ? 1.0 : 0.0;
        r1.xyz = saturate(r1.xyz);
        r1.xyz = float3(16777215,65535,255) * r1.xyz;
        r1.xyz = round(r1.xyz);
        r1.xyz = (uint3)r1.xyz;
        bitmask.y = ((~(-1 << 8)) << 0) & 0xffffffff;  r1.y = (((uint)r1.z << 0) & bitmask.y) | ((uint)r1.y & ~bitmask.y);
        bitmask.x = ((~(-1 << 16)) << 0) & 0xffffffff;  r1.x = (((uint)r1.y << 0) & bitmask.x) | ((uint)r1.x & ~bitmask.x);
        r1.x = (uint)r1.x;
        r1.x = 5.96046519e-008 * r1.x;
        r1.y = r1.x * cb1[65].x + cb1[65].y;
        r1.x = r1.x * cb1[65].z + -cb1[65].w;
        r1.x = 1 / r1.x;
        r1.x = r1.y + r1.x;
        r2.w = r1.w ? r1.x : r2.w;
        r6.xyz = r0.yzw * float3(2,2,2) + float3(-1,-1,-1);
        r7.xyz = float3(0,0,0);
        r5.xyz = float3(0,0,0);
        r0.xw = float2(0,0);
        r3.xy = float2(0,0);
    }
    r0.y = dot(r6.xyz, r6.xyz);
    r0.y = rsqrt(r0.y);
    r1.xyz = r6.xyz * r0.yyy;
    r0.yz = ((int2)r4.xx == int2(5,13)) ? 1.0 : 0.0;
    r1.w = (0 < cb1[162].y) ? 1.0 : 0.0;
    r4.z = (0 < cb1[220].z) ? 1.0 : 0.0;
    r1.w = r1.w ? r4.z : 0;
    r4.z = (0 != cb1[162].y) ? 1.0 : 0.0;
    r6.xyz = r4.zzz ? float3(1,1,1) : r2.xyz;
    r3.w = r3.w ? 1 : 0;
    r6.xyz = r1.www ? r3.www : r6.xyz;
    r2.xyz = r0.yyy ? r6.xyz : r2.xyz;
    r0.y = tex2Dlod(_IN9, float4(0, 0, 0, 0)).x;
    r4.zw = v0.zw * r2.ww; // 此处的v0.zw根据前面的定义将为0
    r6.xyz = cb1[49].xyz * r4.www;
    r6.xyz = r4.zzz * cb1[48].xyz + r6.xyz;
    r6.xyz = r2.www * cb1[50].xyz + r6.xyz;
    r6.xyz = cb1[51].xyz + r6.xyz;
    r4.zw = tex2Dlod(_IN5, float4(v0.xy, 0, 0)).xz;
    r4.zw = r4.zw * r4.zw;
    r1.w = r4.z * r4.w;
    r3.w = cb1[253].y * r1.w;
    if (cb1[255].x != 0) {
        r8.xyz = float3(0,0,0);
        r4.zw = float2(0,0);
        r5.w = 0;
        r6.w = 0;
        while (true) {
        r7.w = ((int)r4.z >= 3) ? 1.0 : 0.0;
        if (r7.w != 0) break;
        r4.w = 0.000833333295 + r4.w;
        r9.xyz = r8.xyz;
        r7.w = r5.w;
        r8.w = r6.w;
        r9.w = 0;
        while (true) {
            r10.x = ((int)r9.w >= 3) ? 1.0 : 0.0;
            if (r10.x != 0) break;
            r7.w = 1 + r7.w;
            r10.x = 2.09439516 * r7.w;
            sincos(r10.x, r10.x, r11.x);
            r11.x = r11.x * r4.w + v0.x;
            r11.y = r10.x * r4.w + v0.y;
            r10.xyz = tex2D(_IN7, r11.xy).xyz;
            r9.xyz = r10.xyz * r4.www + r9.xyz;
            r8.w = r8.w + r4.w;
            r9.w = (int)r9.w + 1;
        }
        r8.xyz = r9.xyz;
        r6.w = r8.w;
        r5.w = 0.620000005 + r7.w;
        r4.z = (int)r4.z + 1;
        }
        r8.xyz = r8.xyz / r6.www;
        r9.xyz = (float3(0.644999981,0.312000006,0.978999972) < r0.xxx) ? 1.0 : 0.0;
        r10.xyz = (r0.xxx < float3(0.685000002,0.351999998,1.02100003)) ? 1.0 : 0.0;
        r9.xyz = r9.xyz ? r10.xyz : 0;
        r0.x = r9.z ? 1.000000 : 0;
        r0.x = r9.y ? 0 : r0.x;
        r0.x = r9.x ? 1 : r0.x;
        r4.z = (int)r9.y | (int)r9.z;
        r4.z = (int)r4.z & 0x3f800000;
        r4.z = r9.x ? 0 : r4.z;
        r3.x = 255 * r3.x;
        r3.x = round(r3.x);
        r3.x = (uint)r3.x;
        r9.xyzw = (int4)r3.xxxx & int4(15,240,240,15);
        r9.xyzw = (uint4)r9.xyzw;
        r3.x = saturate(r0.w + r0.w);
        r4.w = r3.x * -2 + 3;
        r3.x = r3.x * r3.x;
        r3.x = r4.w * r3.x;
        r4.w = -0.5 + r0.w;
        r4.w = saturate(r4.w + r4.w);
        r5.w = r4.w * -2 + 3;
        r4.w = r4.w * r4.w;
        r4.w = r5.w * r4.w;
        r10.xyz = cb1[262].xyz + -cb1[261].xyz;
        r5.w = dot(abs(r10.xyz), float3(0.300000012,0.589999974,0.109999999));
        r5.w = 10 * r5.w;
        r5.w = min(1, r5.w);
        r6.w = r5.w * -2 + 3;
        r5.w = r5.w * r5.w;
        r5.w = r6.w * r5.w;
        r6.w = r5.w * r4.w;
        r7.w = cb1[265].y + -cb1[265].x;
        r8.w = r1.w * cb1[253].y + -cb1[265].x;
        r7.w = 1 / r7.w;
        r8.w = saturate(r8.w * r7.w);
        r10.x = r8.w * -2 + 3;
        r8.w = r8.w * r8.w;
        r8.w = r10.x * r8.w;
        r8.w = r8.w * r6.w;
        r10.x = r1.w * cb1[253].y + -r8.w;
        r8.w = cb1[265].z * r10.x + r8.w;
        r10.x = -cb1[265].x + r8.w;
        r7.w = saturate(r10.x * r7.w);
        r10.x = r7.w * -2 + 3;
        r7.w = r7.w * r7.w;
        r7.w = r10.x * r7.w;
        r6.w = r7.w * r6.w;
        r4.w = r4.w * r5.w + -r6.w;
        r4.w = cb1[265].z * r4.w + r6.w;
        r5.w = -1 + r8.w;
        r5.w = cb1[260].y * r5.w + 1;
        r6.w = r3.w * r4.w + -r5.w;
        r5.w = r5.x * r6.w + r5.w;
        r6.w = r3.w * r4.w + -r4.w;
        r10.x = r5.x * r6.w + r4.w;
        r4.w = (r8.y >= r8.z) ? 1.0 : 0.0;
        r4.w = r4.w ? 1.000000 : 0;
        r11.xy = r8.zy;
        r11.zw = float2(-1,0.666666687);
        r12.xy = -r11.xy + r8.yz;
        r12.zw = float2(1,-1);
        r11.xyzw = r4.wwww * r12.xyzw + r11.xyzw;
        r4.w = (r8.x >= r11.x) ? 1.0 : 0.0;
        r4.w = r4.w ? 1.000000 : 0;
        r12.xyz = r11.xyw;
        r12.w = r8.x;
        r11.xyw = r12.wyx;
        r11.xyzw = r11.xyzw + -r12.xyzw;
        r11.xyzw = r4.wwww * r11.xyzw + r12.xyzw;
        r4.w = min(r11.w, r11.y);
        r4.w = r11.x + -r4.w;
        r6.w = r11.w + -r11.y;
        r7.w = r4.w * 6 + 0.00100000005;
        r6.w = r6.w / r7.w;
        r6.w = r11.z + r6.w;
        r7.w = 0.00100000005 + r11.x;
        r4.w = r4.w / r7.w;
        r7.w = r11.x * 0.300000012 + 1;
        r11.xyzw = r9.xyzw * float4(0.0400000028,0.0027450982,0.00392156886,0.0666666701) + float4(0.400000006,0.400000006,1,0.5);
        r8.w = (r9.z >= 2.54999971) ? 1.0 : 0.0;
        r8.w = r8.w ? 1.000000 : 0;
        r9.x = r11.y + -r11.x;
        r9.x = r8.w * r9.x + r11.x;
        r4.w = r9.x * r4.w;
        r4.w = min(0.349999994, r4.w);
        r9.x = max(0, r4.w);
        r9.yzw = float3(1,0.666666687,0.333333343) + abs(r6.www);
        r9.yzw = frac(r9.yzw);
        r9.yzw = r9.yzw * float3(6,6,6) + float3(-3,-3,-3);
        r9.yzw = saturate(float3(-1,-1,-1) + abs(r9.yzw));
        r9.yzw = float3(-1,-1,-1) + r9.yzw;
        r9.xyz = r9.xxx * r9.yzw + float3(1,1,1);
        r4.w = 1 + r4.w;
        r12.xyz = r9.xyz * r4.www;
        r13.xyz = r9.xyz * r4.www + float3(-1,-1,-1);
        r13.xyz = r13.xyz * float3(0.600000024,0.600000024,0.600000024) + float3(1,1,1);
        r9.xyz = -r9.xyz * r4.www + r13.xyz;
        r9.xyz = r0.xxx * r9.xyz + r12.xyz;
        r12.xyz = r9.xyz + -r2.xyz;
        r12.xyz = r12.xyz * float3(0.850000024,0.850000024,0.850000024) + r2.xyz;
        r11.xyz = r11.zzz * r12.xyz + -r9.xyz;
        r9.xyz = r8.www * r11.xyz + r9.xyz;
        r9.xyz = float3(-1,-1,-1) + r9.xyz;
        r9.xyz = r11.www * r9.xyz + float3(1,1,1);
        r11.xyz = float3(0.200000003,0.200000003,0.200000003) * cb1[261].xyz;
        r12.xyz = cb1[262].xyz * float3(0.5,0.5,0.5) + -r11.xyz;
        r11.xyz = r5.www * r12.xyz + r11.xyz;
        r11.xyz = cb1[260].xxx * r11.xyz;
        r11.xyz = r11.xyz * r2.xyz;
        r12.xyz = r11.xyz * r7.xyz;
        r13.xyz = cb1[261].xyz * r2.xyz;
        r0.x = r3.x * 0.300000012 + 0.699999988;
        r14.xyz = r13.xyz * r0.xxx;
        r15.xyz = cb1[262].xyz * r2.xyz;
        r12.xyz = r13.xyz * r0.xxx + r12.xyz;
        r13.xyz = r2.xyz * cb1[262].xyz + -r14.xyz;
        r13.xyz = r13.xyz * float3(0.400000006,0.400000006,0.400000006) + r14.xyz;
        r16.xyz = r14.xyz * r9.xyz;
        r13.xyz = r13.xyz * r9.xyz + -r16.xyz;
        r13.xyz = r10.xxx * r13.xyz + r16.xyz;
        r11.xyz = r11.xyz * r7.xyz + r13.xyz;
        r12.xyz = r12.xyz * r9.xyz;
        r13.xyz = r15.xyz * r7.www;
        r9.xyz = r13.xyz * r9.xyz + -r12.xyz;
        r9.xyz = r10.xxx * r9.xyz + r12.xyz;
        r0.x = tex2Dlod(_IN8, float4(v0.xy, 0, 0)).x;
        r0.x = -1 + r0.x;
        r0.x = r4.z * r0.x + 1;
        r9.xyz = r9.xyz + -r11.xyz;
        r9.xyz = r5.www * r9.xyz + r11.xyz;
        r11.xyz = float3(1,1,1) + -r8.xyz;
        r8.xyz = r0.xxx * r11.xyz + r8.xyz;
        r8.xyz = r9.xyz * r8.xyz;
    } else {
        r0.x = saturate(r0.w + r0.w);
        r3.x = r0.x * -2 + 3;
        r0.x = r0.x * r0.x;
        r0.x = r3.x * r0.x;
        r3.x = -0.5 + r0.w;
        r3.x = saturate(r3.x + r3.x);
        r4.z = r3.x * -2 + 3;
        r3.x = r3.x * r3.x;
        r3.x = r4.z * r3.x;
        r9.xyz = cb1[262].xyz + -cb1[261].xyz;
        r4.z = dot(abs(r9.xyz), float3(0.300000012,0.589999974,0.109999999));
        r4.z = 10 * r4.z;
        r4.z = min(1, r4.z);
        r4.w = r4.z * -2 + 3;
        r4.z = r4.z * r4.z;
        r4.z = r4.w * r4.z;
        r4.w = r4.z * r3.x;
        r5.w = cb1[265].y + -cb1[265].x;
        r6.w = r1.w * cb1[253].y + -cb1[265].x;
        r5.w = 1 / r5.w;
        r6.w = saturate(r6.w * r5.w);
        r7.w = r6.w * -2 + 3;
        r6.w = r6.w * r6.w;
        r6.w = r7.w * r6.w;
        r6.w = r6.w * r4.w;
        r1.w = r1.w * cb1[253].y + -r6.w;
        r1.w = cb1[265].z * r1.w + r6.w;
        r6.w = -cb1[265].x + r1.w;
        r5.w = saturate(r6.w * r5.w);
        r6.w = r5.w * -2 + 3;
        r5.w = r5.w * r5.w;
        r5.w = r6.w * r5.w;
        r4.w = r5.w * r4.w;
        r3.x = r3.x * r4.z + -r4.w;
        r3.x = cb1[265].z * r3.x + r4.w;
        r4.z = r1.w * r5.y;
        r4.z = 10 * r4.z;
        r1.w = -1 + r1.w;
        r1.w = cb1[260].y * r1.w + 1;
        r4.w = r3.w * r3.x + -r1.w;
        r1.w = r5.x * r4.w + r1.w;
        r4.w = r3.w * r3.x + -r3.x;
        r10.x = r5.x * r4.w + r3.x;
        r5.xyw = float3(0.200000003,0.200000003,0.200000003) * cb1[261].xyz;
        r9.xyz = cb1[262].xyz * float3(0.5,0.5,0.5) + -r5.xyw;
        r5.xyw = r1.www * r9.xyz + r5.xyw;
        r5.xyw = cb1[260].xxx * r5.xyw;
        r5.xyw = r5.xyw * r2.xyz;
        r9.xyz = r5.xyw * r7.xyz;
        r11.xyz = cb1[261].xyz * r2.xyz;
        r0.x = r0.x * 0.300000012 + 0.699999988;
        r14.xyz = r11.xyz * r0.xxx;
        r11.xyz = r11.xyz * r0.xxx + r9.xyz;
        r9.xyz = r9.xyz * r4.zzz + r11.xyz;
        r11.xyz = r2.xyz * cb1[262].xyz + -r14.xyz;
        r11.xyz = r11.xyz * r10.xxx;
        r11.xyz = r11.xyz * float3(0.400000006,0.400000006,0.400000006) + r14.xyz;
        r5.xyw = r5.xyw * r7.xyz + r11.xyz;
        r11.xyz = r2.xyz * cb1[262].xyz + -r9.xyz;
        r9.xyz = r10.xxx * r11.xyz + r9.xyz;
        r9.xyz = r9.xyz + -r5.xyw;
        r8.xyz = r1.www * r9.xyz + r5.xyw;
    }
    r0.x = -0.400000006 + r0.w;
    r0.x = saturate(10.000001 * r0.x);
    r0.w = r0.x * -2 + 3;
    r0.x = r0.x * r0.x;
    r10.y = r0.w * r0.x;
    r5.xyw = r8.xyz * float3(0.5,0.5,0.5) + cb1[261].xyz;
    r5.xyw = r5.xyw * r2.xyz;
    r9.xyz = cb1[261].xyz * r2.xyz;
    r5.xyw = cb1[255].xxx ? r5.xyw : r9.xyz;
    r9.xyz = r0.zzz ? r5.xyw : r14.xyz;
    r5.xyw = r0.zzz ? r5.xyw : r8.xyz;
    r0.xw = r0.zz ? float2(0,0) : r10.xy;
    r8.xyz = cb1[264].xyz + cb1[264].xyz;
    r8.xyz = r0.xxx * r8.xyz + -cb1[264].xyz;
    r10.xyz = float3(0,0,0);
    r1.w = 1;
    r3.x = 0;
    while (true) {
        r4.z = ((uint)r3.x >= asuint(cb2[128].x)) ? 1.0 : 0.0;
        if (r4.z != 0) break;
        bitmask.z = ((~(-1 << 29)) << 3) & 0xffffffff;  r4.z = (((uint)r3.x << 3) & bitmask.z) | ((uint)7 & ~bitmask.z);
        bitmask.w = ((~(-1 << 3)) << 5) & 0xffffffff;  r4.w = (((uint)cb2[r4.z+0].w << 5) & bitmask.w) | ((uint)0 & ~bitmask.w);
        r4.w = (int)r4.y & (int)r4.w;
        if (r4.w == 0) {
        r4.w = (int)r3.x + 1;
        r3.x = r4.w;
        continue;
        }
        r4.w = (uint)r3.x << 3;
        r11.xyz = cb2[r4.w+0].xyz + -r6.xyz;
        r6.w = cb2[r4.w+0].w * cb2[r4.w+0].w;
        r7.w = dot(r11.xyz, r11.xyz);
        r6.w = r7.w * r6.w;
        r8.w = (1 >= r6.w) ? 1.0 : 0.0;
        if (r8.w != 0) {
        bitmask.x = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.x = (((uint)r3.x << 3) & bitmask.x) | ((uint)1 & ~bitmask.x);
        bitmask.y = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.y = (((uint)r3.x << 3) & bitmask.y) | ((uint)2 & ~bitmask.y);
        bitmask.z = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.z = (((uint)r3.x << 3) & bitmask.z) | ((uint)3 & ~bitmask.z);
        bitmask.w = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.w = (((uint)r3.x << 3) & bitmask.w) | ((uint)4 & ~bitmask.w);
        bitmask.x = ((~(-1 << 29)) << 3) & 0xffffffff;  r13.x = (((uint)r3.x << 3) & bitmask.x) | ((uint)5 & ~bitmask.x);
        bitmask.y = ((~(-1 << 29)) << 3) & 0xffffffff;  r13.y = (((uint)r3.x << 3) & bitmask.y) | ((uint)6 & ~bitmask.y);
        r6.w = saturate(r6.w * 2.5 + -1.5);
        r8.w = r6.w * r6.w;
        r6.w = -r6.w * 2 + 3;
        r6.w = -r8.w * r6.w + 1;
        r7.w = rsqrt(r7.w);
        r14.xyz = r11.xyz * r7.www;
        r7.w = dot(r1.xyz, r14.xyz);
        r7.w = 1 + r7.w;
        r13.zw = cb2[r13.x+0].ww * float2(0.939999998,0.0600000024);
        r7.w = r7.w * 0.5 + -r13.z;
        r8.w = 1 / r13.w;
        r7.w = saturate(r8.w * r7.w);
        r8.w = r7.w * -2 + 3;
        r7.w = r7.w * r7.w;
        r7.w = r8.w * r7.w;
        r7.w = min(1, r7.w);
        r15.xyz = cb2[r13.y+0].xyz * r9.xyz;
        r13.xzw = r2.xyz * cb2[r13.x+0].xyz + -r15.xyz;
        r13.xzw = r7.www * r13.xzw + r15.xyz;
        r13.xzw = cb2[r4.z+0].xxx * r13.xzw;
        r11.xyz = cb2[r4.w+0].www * r11.xyz;
        r4.w = dot(r11.xyz, r11.xyz);
        r4.w = r4.w * cb2[r12.w+0].x + cb2[r12.w+0].y;
        r4.w = 9.99999975e-005 + r4.w;
        r4.w = 1 / r4.w;
        r4.w = -1 + r4.w;
        r4.w = cb2[r12.w+0].z * r4.w;
        r4.w = r4.w * r4.w;
        r4.w = min(1, r4.w);
        if (4 == 0) r7.w = 0; else if (4+16 < 32) {       r7.w = (uint)cb2[r12.x+0].w << (32-(4 + 16)); r7.w = (uint)r7.w >> (32-4);      } else r7.w = (uint)cb2[r12.x+0].w >> 16;
        r7.w = ((int)r7.w == 2) ? 1.0 : 0.0;
        r8.w = dot(r14.xyz, cb2[r12.x+0].xyz);
        r8.w = -cb2[r12.y+0].x + r8.w;
        r8.w = saturate(cb2[r12.y+0].y * r8.w);
        r8.w = r8.w * r8.w;
        r8.w = r8.w * r8.w;
        r8.w = r8.w * r4.w;
        r4.w = r7.w ? r8.w : r4.w;
        r7.w = dot(r8.xyz, r14.xyz);
        r7.w = saturate(r7.w * 0.5 + 0.5);
        r7.w = r0.w * r7.w + -r0.x;
        r7.w = cb2[r12.w+0].w * r7.w + r0.x;
        r11.xyz = cb2[r12.z+0].www * r9.xyz;
        r12.xyw = -r9.xyz * cb2[r12.z+0].www + r2.xyz;
        r11.xyz = r7.www * r12.xyw + r11.xyz;
        r11.xyz = cb2[r12.z+0].xyz * r11.xyz;
        r7.w = cb2[r12.z+0].x + cb2[r12.z+0].y;
        r7.w = cb2[r12.z+0].z + r7.w;
        r7.w = cb2[r4.z+0].x + r7.w;
        r7.w = saturate(10 * r7.w);
        r4.z = cb2[r4.z+0].y * r7.w;
        r12.xyz = r13.xzw * r4.www;
        r11.xyz = r11.xyz * r4.www + r12.xyz;
        r6.w = r6.w + -r4.w;
        r4.w = cb2[r13.y+0].w * r6.w + r4.w;
        r10.xyz = r11.xyz * r1.www + r10.xyz;
        r4.z = -r4.w * r4.z + 1;
        r1.w = r4.z * r1.w;
        }
        r3.x = (int)r3.x + 1;
    }
    r4.yzw = r1.www * r5.xyw + r10.xyz;
    r0.x = ((int)r4.x != 13) ? 1.0 : 0.0;
    if (r0.x != 0) {
        r0.x = ((int)r4.x == 1) ? 1.0 : 0.0;
        r0.x = r0.x ? r3.z : r3.y;
        r3.xyz = cb1[67].xyz + -r6.xyz;
        r0.w = dot(r3.xyz, r3.xyz);
        r0.w = rsqrt(r0.w);
        r3.xyz = r3.xyz * r0.www;
        r0.w = saturate(-0.100000001 + r0.x);
        r0.x = saturate(10 * r0.x);
        r1.w = r0.w * 2000 + 50;
        r4.x = r0.w + r0.w;
        r0.x = cb0[0].x * r0.x;
        r0.x = r0.x * 0.800000012 + r4.x;
        r5.xyw = cb1[21].xyz * r1.yyy;
        r5.xyw = r1.xxx * cb1[20].xyz + r5.xyw;
        r5.xyw = r1.zzz * cb1[22].xyz + r5.xyw;
        r4.x = asint(cb0[0].w);
        r4.x = (0.5 < r4.x) ? 1.0 : 0.0;
        r3.xyz = r4.xxx ? float3(0,0,0) : r3.xyz;
        r6.xy = r4.xx ? cb0[0].yz : cb1[264].xy;
        r6.z = r4.x ? 0.5 : cb1[264].z;
        r1.xyz = r4.xxx ? r5.xyw : r1.xyz;
        r4.x = dot(r6.xyz, r1.xyz);
        r8.xy = float2(0.200000003,1) + r4.xx;
        r4.x = 5 * r8.x;
        r4.x = saturate(r4.x);
        r5.w = r4.x * -2 + 3;
        r4.x = r4.x * r4.x;
        r4.x = r5.w * r4.x;
        r8.xzw = r6.xyz + r3.xyz;
        r5.w = dot(r8.xzw, r8.xzw);
        r5.w = rsqrt(r5.w);
        r8.xzw = r8.xzw * r5.www;
        r5.w = saturate(dot(r1.xyz, r8.xzw));
        r5.w = r5.w * r5.w;
        r5.w = r5.w * -0.800000012 + 1;
        r5.w = r5.w * r5.w;
        r5.w = 3.14159274 * r5.w;
        r5.w = 0.200000003 / r5.w;
        r5.w = r5.w * r3.w;
        r6.x = dot(r6.xyz, r3.xyz);
        r6.xy = float2(-0.5,1) + -r6.xx;
        r6.x = saturate(r6.x + r6.x);
        r6.z = r6.x * -2 + 3;
        r6.x = r6.x * r6.x;
        r6.x = r6.z * r6.x + 1;
        r1.x = saturate(dot(r3.xyz, r1.xyz));
        r1.x = 0.800000012 + -r1.x;
        r1.x = max(0, r1.x);
        r1.y = max(0, cb1[133].x);
        r1.y = min(1.74532926, r1.y);
        r1.xy = float2(1.5,0.572957814) * r1.xy;
        r1.z = max(0, r2.w);
        r3.xy = min(float2(3000,50), r1.zz);
        r3.xy = float2(3000,50) + -r3.xy;
        r3.xy = float2(0.00033333333,0.0199999996) * r3.xy;
        r1.z = r3.x * r3.x;
        r1.z = r1.z * r1.z;
        r1.z = r1.z * r1.z + r3.y;
        r1.z = -1 + r1.z;
        r1.y = r1.y * r1.z + 1;
        r1.z = 1 + -r1.y;
        r1.y = r0.w * r1.z + r1.y;
        r1.z = r8.y * 0.25 + 0.5;
        r1.x = r1.z * r1.x;
        r1.x = r1.x * r1.y;
        r1.x = r1.x * r6.x;
        r1.x = 0.00999999978 * r1.x;
        r3.xy = float2(9.99999975e-005,9.99999975e-005) + r5.xy;
        r1.z = dot(r3.xy, r3.xy);
        r1.z = rsqrt(r1.z);
        r3.xy = r3.xy * r1.zz;
        r3.xy = r3.xy * r0.xx;
        r3.z = r3.y * r1.x;
        r1.y = -0.5;
        r1.xy = r3.xz * r1.xy;
        r0.x = 0.400000006 * r6.y;
        r1.z = r4.x * 0.800000012 + 0.200000003;
        r3.x = r5.w * r4.x;
        r3.x = 1.5 * r3.x;
        r0.x = r0.x * r1.z + r3.x;
        r1.z = r3.w * 0.5 + 0.5;
        r0.x = r1.z * r0.x;
        r3.xy = v0.xy * cb1[138].xy + -cb1[134].xy;
        r1.xy = r3.xy * cb1[135].zw + r1.xy;
        r1.xy = r1.xy * cb1[135].xy + cb1[134].xy;
        r1.xy = cb1[138].zw * r1.xy;
        r1.x = tex2D(_IN6, r1.xy).x;
        r1.y = r1.x * cb1[65].x + cb1[65].y;
        r1.x = r1.x * cb1[65].z + -cb1[65].w;
        r1.x = 1 / r1.x;
        r1.x = r1.y + r1.x;
        r1.x = r1.x + -r2.w;
        r1.x = max(9.99999975e-005, r1.x);
        r0.w = -r0.w * 1000 + r1.x;
        r1.x = 1 / r1.w;
        r0.w = saturate(r1.x * r0.w);
        r1.x = r0.w * -2 + 3;
        r0.w = r0.w * r0.w;
        r0.w = r1.x * r0.w;
        r0.w = min(1, r0.w);
        r1.x = dot(cb1[263].xyz, float3(0.300000012,0.589999974,0.109999999));
        r1.yzw = cb1[263].xyz + -r1.xxx;
        r1.xyz = r1.yzw * float3(0.75,0.75,0.75) + r1.xxx;
        r3.xyz = cb1[263].xyz + -r1.xyz;
        r1.xyz = r3.www * r3.xyz + r1.xyz;
        r1.xyz = r1.xyz * r0.xxx;
        r1.xyz = float3(0.100000001,0.100000001,0.100000001) * r1.xyz;
        r3.xyz = float3(1,1,1) + r2.xyz;
        r3.xyz = r3.xyz * r1.xyz;
        r5.xyw = r2.xyz * float3(1.20000005,1.20000005,1.20000005) + float3(-1,-1,-1);
        r5.xyw = saturate(-r5.xyw);
        r6.xyz = r5.xyw * float3(-2,-2,-2) + float3(3,3,3);
        r5.xyw = r5.xyw * r5.xyw;
        r5.xyw = r6.xyz * r5.xyw;
        r5.xyw = r5.xyw * float3(14,14,14) + float3(1,1,1);
        r1.xyz = r5.xyw * r1.xyz;
        r1.xyz = r1.xyz * r2.xyz + -r3.xyz;
        r1.xyz = cb1[260].zzz * r1.xyz + r3.xyz;
        r1.xyz = r1.xyz * r0.www;
        r0.x = -10000 + r2.w;
        r0.x = max(0, r0.x);
        r0.x = min(5000, r0.x);
        r0.x = 5000 + -r0.x;
        r0.x = 0.000199999995 * r0.x;
        r1.xyz = r0.xxx * r1.xyz;
        r1.xyz = cb0[1].xyz * r1.xyz;
    } else {
        r1.xyz = float3(0,0,0);
    }
    r0.x = (0 != r5.z) ? 1.0 : 0.0;
    r2.xyz = r4.yzw * r7.xyz;
    r2.xyz = cb1[263].xyz * r2.xyz;
    r2.xyz = r2.xyz * float3(0.5,0.5,0.5) + -r4.yzw;
    r2.xyz = r0.www * r2.xyz + r4.yzw;
    r1.xyz = r4.yzw + r1.xyz;
    r1.xyz = r0.xxx ? r2.xyz : r1.xyz;
    r0.xzw = r0.zzz ? r4.yzw : r1.xyz;
    r0.xyz = r0.xzw / r0.yyy;
    r0.xyz = min(float3(0,0,0), -r0.xyz);
    color.xyz = -r0.xyz;
    return color;
}