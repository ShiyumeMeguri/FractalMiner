角色设定 (Persona):
你是一位顶级的国家首席图形程序员和着色器逆向工程专家。你精通HLSL、渲染管线以及编译器如何将高级着色器代码转换为汇编指令。你的核心能力是精确分析和复现复杂的着色器逻辑。
任务指令 (Your Task):
仔细分析下面提供的所有代码（A, B）。
A是重命名后的结果 B是正确源码编译结果
识别出代码A中所有与代码B不一致的逻辑错误。
禁止省略任何代码。请为我提供一份完整、准确、可以直接编译的、已修复的代码A。
这份修复后的代码必须严格遵循代码D的逻辑流程，目标是实现与B源码的编译等价性,不能使用unroll 不能添加注释 不能把A的代码直接替换为B的代码或命名来解决问题。

A:float4 frag (VertexToFragment fragmentInput) : SV_Target
{
    float4 screenUV = fragmentInput.uv;

    float4 tex1 = tex2Dlod(_IN1, float4(screenUV.xy, 0, 0)).wxyz;
    float perObjectData = tex1.x;
    float3 gbuffer_normal = tex1.yzw;
    
    float4 tex2 = tex2Dlod(_IN2, float4(screenUV.xy, 0, 0)).xyzw;
    float3 msr = tex2.xyz;
    float shadingModelID_raw = tex2.w;
    
    float3 baseColor = tex2Dlod(_IN3, float4(screenUV.xy, 0, 0)).xyz;
    
    float3 tex4 = tex2Dlod(_IN4, float4(screenUV.xy, 0, 0)).yxz;
    
    float depth = tex2Dlod(_IN0, float4(screenUV.xy, 0, 0)).x;
    
    float temp_depth_calc = depth * cb1[65].x + cb1[65].y;
    float linearizedDepth_part1 = depth * cb1[65].z - cb1[65].w;
    float linearizedDepth_part2 = 1.0 / linearizedDepth_part1;
    depth = temp_depth_calc + linearizedDepth_part2;
    
    float2 tileCoords = cb1[138].xy * screenUV.xy;
    tileCoords = (uint2)tileCoords;
    float cb158 = (uint)cb1[158].x;
    float tileCoordsSum = (int)tileCoords.y + (int)tileCoords.x;
    cb158 = (int)cb158 + (int)tileCoordsSum;
    float isOddPixel = (int)cb158 & 1;

    float shadingModelID_rounded = round(255.0 * shadingModelID_raw);
    uint uint_shadingModelID_rounded = (uint)shadingModelID_rounded;
    int intShadingModelID = (int)(float)uint_shadingModelID_rounded;
    int2 shadingModelBitfields = int2(intShadingModelID & 15, intShadingModelID & -16);
    
    bool bIsNotClothShadingModel = (shadingModelBitfields.x != 12);
    bool bIsModel13 = (shadingModelBitfields.x == 13);
    bool bIsModel14 = (shadingModelBitfields.x == 14);
    bool bIsModel15 = (shadingModelBitfields.x == 15);
    bool bIsAnySpecialModel = bIsModel13 || bIsModel14 || bIsModel15;

    float isAnySpecialModel = bIsAnySpecialModel ? 1.0f : 0.0f;
    float shadingModelOverride = bIsNotClothShadingModel ? isAnySpecialModel : -1.0f;

    float3 worldNormal;
    float3 initialLighting;
    float hairShadowingFactor = 0.0;
    float3 final_gbuffer_normal = gbuffer_normal; 
    
    float temp_shading_id_holder = (float)shadingModelBitfields.x;

    if (shadingModelOverride != 0.0)
    {
        temp_shading_id_holder = bIsModel13 ? 13.0 : 12.0;

        float2 encodedNormal = gbuffer_normal.xy * 2.0 - 1.0;
        float encodedNormalAbsSum = dot(float2(1.0, 1.0), abs(encodedNormal));
        float worldNormalZ_unpacked = 1.0 - encodedNormalAbsSum;
        float unpack_factor = max(0.0, -worldNormalZ_unpacked);
        float2 lightingSign = (encodedNormal >= float2(0.0, 0.0)) ? float2(0.5, 0.5) : float2(-0.5, -0.5);
        float2 lightingOffset = lightingSign * unpack_factor;
        float2 worldNormalXY_unpacked = lightingOffset * -2.0 + encodedNormal;
        worldNormal = float3(worldNormalXY_unpacked.x, worldNormalXY_unpacked.y, worldNormalZ_unpacked);
        
        float worldNormalLengthRsqrt = rsqrt(dot(worldNormal, worldNormal));
        worldNormal = worldNormal * worldNormalLengthRsqrt;

        initialLighting = msr * msr;
        hairShadowingFactor = tex4.z;
    }
    else
    {
        float isClearCoatModel = (shadingModelBitfields.x == 10) ? 1.0 : 0.0;

        float3 saturated_msr = saturate(msr);
        float3 scaled_msr = float3(16777215.0, 65535.0, 255.0) * saturated_msr;
        uint3 rounded_msr = (uint3)round(scaled_msr);
        
        uint packed_val_x = (rounded_msr.x & 0xFF0000) + (rounded_msr.y & 0xFF00) + rounded_msr.z;

        float packed_depth_float = 0.0 * (float)packed_val_x;
        float linear_depth_temp = packed_depth_float * cb1[65].x + cb1[65].y;
        float linear_depth_p1 = packed_depth_float * cb1[65].z - cb1[65].w;
        float linear_depth_p2 = 1.0 / linear_depth_p1;
        float final_packed_depth = linear_depth_temp + linear_depth_p2;
        
        depth = (isClearCoatModel != 0.0) ? final_packed_depth : depth;

        worldNormal = final_gbuffer_normal * 2.0 - 1.0;
        initialLighting = float3(0.0, 0.0, 0.0);
        perObjectData = 0.0;
        tex4.xy = 0;
    }
    
    float worldNormalLengthRsqrt = rsqrt(dot(worldNormal, worldNormal));
    float3 normalizedWorldNormal = worldNormal * worldNormalLengthRsqrt;

    int temp_int_shading_id = (int)temp_shading_id_holder;
    float isShadingModel_5 = (temp_int_shading_id == 5) ? 1.0 : 0.0;
    float isShadingModel_13 = (temp_int_shading_id == 13) ? 1.0 : 0.0;

    float hasValidFogData = (0.0 < cb1[162].y) ? 1.0 : 0.0;
    float hasVolumetricFog = (0.0 < cb1[220].z) ? 1.0 : 0.0;
    float useVolumetricFog = hasValidFogData ? hasVolumetricFog : 0.0;
    float useDitheredLodTransition = (0.0 != cb1[162].y) ? 1.0 : 0.0;
    
    float3 processedBaseColor = useDitheredLodTransition ? float3(1.0, 1.0, 1.0) : baseColor;
    float useOddPixelResult = isOddPixel ? 1.0 : 0.0;
    processedBaseColor = useVolumetricFog ? useOddPixelResult.xxx : processedBaseColor;
    baseColor = (isShadingModel_5 != 0.0) ? processedBaseColor : baseColor;
    
    float aoFactor = tex2Dlod(_IN9, float4(0.0, 0.0, 0.0, 0.0)).x;

    float3 worldPos = depth * cb1[50].xyz + cb1[51].xyz;

    float2 shadowmask_shadowIntensity = tex2Dlod(_IN5, float4(screenUV.xy, 0, 0)).xz;
    float2 shadowmask_shadowIntensitySq = shadowmask_shadowIntensity * shadowmask_shadowIntensity;
    float shadowMaskIntensity = shadowmask_shadowIntensitySq.x * shadowmask_shadowIntensitySq.y;

    float shadowmaskTerm_preBlend = cb1[253].y * shadowMaskIntensity;

    float3 indirectLightingResult;
    float3 diffuseIBLBase;
    
    if (cb1[255].x != 0.0)
    {
        float3 accumulatedGIBounceColor = float3(0.0, 0.0, 0.0);
        float giRadius = 0.0;
        float giTotalWeight = 0.0;
        float giAngleCounter = 0.0;
        
        for (int i = 0; i < 3; ++i)
        {
            float sampleRadius = 0.000833333295 + giRadius;
            float3 currentLoopColor = accumulatedGIBounceColor;
            float currentSampleAngle = giAngleCounter;
            
            for (int j = 0; j < 3; ++j)
            {
                currentSampleAngle = 1.0 + currentSampleAngle;
                float angle_rad = 2.09439516 * currentSampleAngle;
                float sin_a, cos_a;
                sincos(angle_rad, sin_a, cos_a);
                float2 sampleUV_offset = float2(cos_a, sin_a) * sampleRadius;
                float2 sampleUV = screenUV.xy + sampleUV_offset;
                float3 giSampleColor = tex2D(_IN7, sampleUV).xyz;
                
                currentLoopColor = giSampleColor * sampleRadius + currentLoopColor;
                giTotalWeight = giTotalWeight + sampleRadius;
            }
            accumulatedGIBounceColor = currentLoopColor;
            giAngleCounter = 0.620000005 + currentSampleAngle;
            giRadius = sampleRadius;
        }
        
        float3 finalGIColor = accumulatedGIBounceColor / giTotalWeight;

        float3 perObjectMask_high = (float3(0.644999981, 0.312000006, 0.978999972) < perObjectData.xxx) ? 1.0 : 0.0;
        float3 perObjectMask_low = (perObjectData.xxx < float3(0.685000002, 0.351999998, 1.02100003)) ? 1.0 : 0.0;
        float3 perObjectMask = perObjectMask_high * perObjectMask_low;
        float maskResult = perObjectMask.z ? 1.0 : 0.0;
        maskResult = perObjectMask.y ? 0.0 : maskResult;
        maskResult = perObjectMask.x ? 1.0 : maskResult;
        
        float customData_rounded = round(255.0 * tex4.x);
        uint4 customDataMasks = (uint4)((uint)customData_rounded) & uint4(15, 240, 240, 15);
        
        float fresnelTerm_IBL = saturate(final_gbuffer_normal.z + final_gbuffer_normal.z);
        float fresnel_factor1_IBL = fresnelTerm_IBL * -2.0 + 3.0;
        fresnelTerm_IBL = fresnelTerm_IBL * fresnelTerm_IBL;
        float roughness_from_normal = fresnel_factor1_IBL * fresnelTerm_IBL;

        float roughness_term = saturate(final_gbuffer_normal.z * 2.0 - 1.0);
        float roughness_factor = roughness_term * -2.0 + 3.0;
        roughness_term = roughness_term * roughness_term;
        float roughness_final = roughness_factor * roughness_term;
        
        float3 color_diff = cb1[262].xyz - cb1[261].xyz;
        float luma = dot(abs(color_diff), float3(0.300000012, 0.589999974, 0.109999999));
        float luma_scaled = min(1.0, 10.0 * luma);
        float luma_factor = luma_scaled * -2.0 + 3.0;
        luma_scaled = luma_scaled * luma_scaled;
        float luma_fresnel = luma_factor * luma_scaled;
        
        float blended_roughness = luma_fresnel * roughness_final;
        
        float blend_range = cb1[265].y - cb1[265].x;
        float blend_inv_range = 1.0 / blend_range;
        float blend_val = shadowmaskTerm_preBlend - cb1[265].x;
        float blend_ratio = saturate(blend_val * blend_inv_range);
        float blend_factor = blend_ratio * -2.0 + 3.0;
        blend_ratio = blend_ratio * blend_ratio;
        float blend_fresnel = blend_factor * blend_ratio;
        
        float final_blend = blend_fresnel * blended_roughness;
        float ssr_term = shadowmaskTerm_preBlend - final_blend;
        float final_ssr = cb1[265].z * ssr_term + final_blend;
        
        float ssr_clamped = -cb1[265].x + final_ssr;
        float ssr_ratio = saturate(ssr_clamped * blend_inv_range);
        float ssr_factor = ssr_ratio * -2.0 + 3.0;
        ssr_ratio = ssr_ratio * ssr_ratio;
        float ssr_fresnel = ssr_factor * ssr_ratio;
        blended_roughness = ssr_fresnel * blended_roughness;
        
        float combined_roughness = roughness_final * luma_fresnel - blended_roughness;
        combined_roughness = cb1[265].z * combined_roughness + blended_roughness;
        
        float final_spec_occlusion = cb1[260].y * (final_ssr - 1.0) + 1.0;
        float spec_ao_combined = roughness_from_normal * combined_roughness - final_spec_occlusion;
        final_spec_occlusion = isAnySpecialModel * spec_ao_combined + final_spec_occlusion;
        
        float spec_ao_combined_2 = roughness_from_normal * combined_roughness - combined_roughness;
        float accumulatedLightColor_x = isAnySpecialModel * spec_ao_combined_2 + combined_roughness;
        
        float3 hsv_modulated_color;
        {
            float hsv_check = (finalGIColor.y >= finalGIColor.z) ? 1.0 : 0.0;
            float2 hsv_prep1 = finalGIColor.zy;
            float4 hsv_consts1 = float4(-1.0, 0.666666687, 1.0, -1.0);
            float4 hsv_interp1 = hsv_check * (-hsv_prep1.xyxy + finalGIColor.yzyy) + float4(hsv_prep1.x, hsv_prep1.y, hsv_consts1.z, hsv_consts1.w);
            float hsv_check2 = (finalGIColor.x >= hsv_interp1.x) ? 1.0 : 0.0;
            float4 hsv_prep2 = float4(hsv_interp1.x, hsv_interp1.y, hsv_interp1.w, finalGIColor.x);
            float4 hsv_interp2 = hsv_check2 * (hsv_prep2.wyxz - hsv_prep2.xyzw) + hsv_prep2;
            float hsv_V_minus_min = hsv_interp2.x - min(hsv_interp2.w, hsv_interp2.y);
            float hsv_V_minus_min_plus_delta = hsv_interp2.w - hsv_interp2.y;
            float hsv_H = hsv_interp2.z + hsv_V_minus_min_plus_delta / (hsv_V_minus_min * 6.0 + 0.00100000005);
            float hsv_S_unclamped = hsv_V_minus_min / (hsv_interp2.x + 0.00100000005);
            float4 customDataMasks_shifted = (float4)customDataMasks * float4(0.0400000028, 0.0027450982, 0.00392156886, 0.0666666701) + float4(0.400000006, 0.400000006, 1.0, 0.5);
            float custom_mask_z_check = (customDataMasks.z >= 2.54999971) ? 1.0 : 0.0;
            float custom_mask_x = custom_mask_z_check * (customDataMasks_shifted.y - customDataMasks_shifted.x) + customDataMasks_shifted.x;
            float hsv_S = min(0.349999994, custom_mask_x * hsv_S_unclamped);
            float hsv_S_clamped = max(0.0, hsv_S);
            float3 hsv_frac_H = frac(float3(1.0, 0.666666687, 0.333333343) + hsv_H.xxx);
            float3 hsv_remap_H = saturate(abs(hsv_frac_H * 6.0 - 3.0) - 1.0);
            float3 hsv_to_rgb_base = hsv_remap_H - 1.0;
            float3 hsv_to_rgb_interp = hsv_S_clamped * hsv_to_rgb_base + 1.0;
            float3 base_hsv_rgb = hsv_to_rgb_interp * (hsv_S_unclamped + 1.0);
            float3 lerp_factor_1 = (hsv_to_rgb_interp * (hsv_S_unclamped + 1.0) - 1.0) * 0.600000024 + 1.0;
            float3 lerp_factor_2 = -hsv_to_rgb_interp * (hsv_S_unclamped + 1.0) + lerp_factor_1;
            float3 final_hsv_rgb_1 = maskResult * lerp_factor_2 + base_hsv_rgb;
            float3 final_hsv_rgb_2 = (final_hsv_rgb_1 - baseColor) * 0.850000024 + baseColor;
            float3 hsv_blend_factor = customDataMasks_shifted.z * final_hsv_rgb_2 - final_hsv_rgb_1;
            float3 final_hsv_rgb_3 = custom_mask_z_check * hsv_blend_factor + final_hsv_rgb_1;
            hsv_modulated_color = (-1.0 + final_hsv_rgb_3) * customDataMasks_shifted.w + 1.0;
        }
        
        float3 indirect_spec_base = 0.200000003 * cb1[261].xyz;
        float3 indirect_spec_add = cb1[262].xyz * 0.5 - indirect_spec_base;
        indirect_spec_base = final_spec_occlusion * indirect_spec_add + indirect_spec_base;
        indirect_spec_base = cb1[260].xxx * indirect_spec_base;
        indirect_spec_base = indirect_spec_base * baseColor;
        
        float3 indirect_spec_lit = indirect_spec_base * initialLighting;
        float3 indirect_diffuse_lit = cb1[261].xyz * baseColor;
        float ibl_factor = roughness_from_normal * 0.300000012 + 0.699999988;
        diffuseIBLBase = indirect_diffuse_lit * ibl_factor;
        
        float3 ibl_spec_base_plus_diffuse = diffuseIBLBase + indirect_spec_lit;
        float3 hsv_modulated_ibl_spec_base = ibl_spec_base_plus_diffuse * hsv_modulated_color;
        
        float3 ibl_diffuse_add = baseColor * cb1[262].xyz - diffuseIBLBase;
        float3 ibl_diffuse_lerp = ibl_diffuse_add * 0.400000006 + diffuseIBLBase;
        
        float3 ibl_spec_occluded = diffuseIBLBase * hsv_modulated_color;
        float3 ibl_diffuse_occluded = (ibl_diffuse_lerp * hsv_modulated_color) - ibl_spec_occluded;
        float3 ibl_diffuse_final = accumulatedLightColor_x * ibl_diffuse_occluded + ibl_spec_occluded;
        
        float3 final_ibl_spec = (initialLighting * hsv_modulated_color) - hsv_modulated_ibl_spec_base;
        final_ibl_spec = accumulatedLightColor_x * final_ibl_spec + hsv_modulated_ibl_spec_base;
        
        float3 lightLoopTempA_resolved = indirect_spec_lit + ibl_diffuse_final;
        float3 final_ibl_spec_temp = final_ibl_spec - lightLoopTempA_resolved;
        final_ibl_spec = luma_fresnel * final_ibl_spec_temp + lightLoopTempA_resolved;
        
        indirectLightingResult = final_ibl_spec;
    }
    else
    {
        float fresnelTerm_NdotV_alt = saturate(final_gbuffer_normal.z + final_gbuffer_normal.z);
        float fresnel_factor1_alt = fresnelTerm_NdotV_alt * -2.0 + 3.0;
        fresnelTerm_NdotV_alt = fresnelTerm_NdotV_alt * fresnelTerm_NdotV_alt;
        float fresnel_NdotV_alt = fresnel_factor1_alt * fresnelTerm_NdotV_alt;
        
        float roughness_term_alt = saturate(final_gbuffer_normal.z * 2.0 - 1.0);
        float specularMask_alt = roughness_term_alt * -2.0 + 3.0;
        roughness_term_alt = roughness_term_alt * roughness_term_alt;
        float roughness_final_alt = specularMask_alt * roughness_term_alt;
        
        float3 color_diff_alt = cb1[262].xyz - cb1[261].xyz;
        float luma_alt = dot(abs(color_diff_alt), float3(0.300000012, 0.589999974, 0.109999999));
        luma_alt = min(1.0, 10.0 * luma_alt);
        float luma_factor_alt = luma_alt * -2.0 + 3.0;
        luma_alt = luma_alt * luma_alt;
        float luma_fresnel_alt = luma_factor_alt * luma_alt;
        
        float blended_roughness_alt = luma_fresnel_alt * roughness_final_alt;
        
        float blend_range_alt = cb1[265].y - cb1[265].x;
        float blend_inv_range_alt = 1.0 / blend_range_alt;
        float blend_val_alt = shadowMaskIntensity * cb1[253].y - cb1[265].x;
        float blend_ratio_alt = saturate(blend_val_alt * blend_inv_range_alt);
        float blend_factor_alt = blend_ratio_alt * -2.0 + 3.0;
        blend_ratio_alt = blend_ratio_alt * blend_ratio_alt;
        float blend_fresnel_alt = blend_factor_alt * blend_ratio_alt;
        
        float final_blend_alt = blend_fresnel_alt * blended_roughness_alt;
        float ssr_term_alt = shadowMaskIntensity * cb1[253].y - final_blend_alt;
        float final_ssr_alt = cb1[265].z * ssr_term_alt + final_blend_alt;
        
        float ssr_clamped_alt = -cb1[265].x + final_ssr_alt;
        float ssr_ratio_alt = saturate(ssr_clamped_alt * blend_inv_range_alt);
        float ssr_factor_alt = ssr_ratio_alt * -2.0 + 3.0;
        ssr_ratio_alt = ssr_ratio_alt * ssr_ratio_alt;
        float ssr_fresnel_alt = ssr_factor_alt * ssr_ratio_alt;
        blended_roughness_alt = ssr_fresnel_alt * blended_roughness_alt;
        
        float combined_roughness_alt = roughness_final_alt * luma_fresnel_alt - blended_roughness_alt;
        combined_roughness_alt = cb1[265].z * combined_roughness_alt + blended_roughness_alt;
        
        float final_spec_occlusion_alt = cb1[260].y * (final_ssr_alt - 1.0) + 1.0;
        float spec_ao_combined_alt = fresnel_NdotV_alt * combined_roughness_alt - final_spec_occlusion_alt;
        final_spec_occlusion_alt = isAnySpecialModel * spec_ao_combined_alt + final_spec_occlusion_alt;
        
        float spec_ao_combined_2_alt = fresnel_NdotV_alt * combined_roughness_alt - combined_roughness_alt;
        float accumulatedLightColor_x_alt = isAnySpecialModel * spec_ao_combined_2_alt + combined_roughness_alt;
        
        float3 indirect_spec_base_alt = 0.200000003 * cb1[261].xyz;
        float3 indirect_spec_add_alt = cb1[262].xyz * 0.5 - indirect_spec_base_alt;
        indirect_spec_base_alt = final_spec_occlusion_alt * indirect_spec_add_alt + indirect_spec_base_alt;
        indirect_spec_base_alt = cb1[260].xxx * indirect_spec_base_alt;
        indirect_spec_base_alt = indirect_spec_base_alt * baseColor;
        
        float3 indirect_spec_lit_alt = indirect_spec_base_alt * initialLighting;
        float3 indirect_diffuse_lit_alt = cb1[261].xyz * baseColor;
        float ibl_factor_alt = fresnel_NdotV_alt * 0.300000012 + 0.699999988;
        
        diffuseIBLBase = indirect_diffuse_lit_alt * ibl_factor_alt;
        
        float3 temp_spec_plus_diffuse_base = diffuseIBLBase + indirect_spec_lit_alt;
        float3 temp_lighting_C = luma_fresnel_alt * shadowMaskIntensity + temp_spec_plus_diffuse_base;
        
        float3 temp_diffuse_add = baseColor * cb1[262].xyz - diffuseIBLBase;
        temp_diffuse_add = temp_diffuse_add * accumulatedLightColor_x_alt;
        float3 temp_diffuse_final = temp_diffuse_add * 0.400000006 + diffuseIBLBase;

        float3 term_B_final = indirect_spec_lit_alt + temp_diffuse_final;

        float3 term_A_base = baseColor * cb1[262].xyz - temp_lighting_C;
        float3 term_A_final = accumulatedLightColor_x_alt * term_A_base + temp_lighting_C;

        float3 term_A_minus_B = term_A_final - term_B_final;
        indirectLightingResult = final_spec_occlusion_alt * term_A_minus_B + term_B_final;
    }

    float subsurf_scatter_term = saturate(10.000001 * (final_gbuffer_normal.z - 0.400000006));
    float subsurf_fresnel_factor = subsurf_scatter_term * -2.0 + 3.0;
    subsurf_scatter_term = subsurf_scatter_term * subsurf_scatter_term;
    float subsurf_fresnel = subsurf_fresnel_factor * subsurf_scatter_term;

    float3 preLoopLighting_IBL = indirectLightingResult * 0.5 + cb1[261].xyz;
    preLoopLighting_IBL = preLoopLighting_IBL * baseColor;
    float3 preLoopLighting_NonIBL = cb1[261].xyz * baseColor;
    float3 chosenPreLoopLighting = (cb1[255].x != 0.0) ? preLoopLighting_IBL : preLoopLighting_NonIBL;

    diffuseIBLBase = isShadingModel_5 ? chosenPreLoopLighting : diffuseIBLBase;
    indirectLightingResult = isShadingModel_5 ? chosenPreLoopLighting : indirectLightingResult;
    
    float finalSubsurfTerm = isShadingModel_5 ? 0.0 : subsurf_fresnel;
    float finalSubsurfScatter = isShadingModel_5 ? 0.0 : subsurf_scatter_term;
    
    float3 foggedLighting = (finalSubsurfTerm * (cb1[264].xyz + cb1[264].xyz)) - cb1[264].xyz;
    float3 lightAccumulator = float3(0.0, 0.0, 0.0);
    float lightLoopFalloff = 1.0;
    
    uint lightLoopCounter = 0;
    uint numLights = asuint(cb2[128].x);
    
    while (lightLoopCounter < numLights)
    {
        uint lightIndex_base = lightLoopCounter << 3;
        uint lightDataIndex = lightIndex_base | 7;
        uint lightTypeMask = (uint)shadingModelBitfields.y & ((asuint(cb2[lightDataIndex].w) << 5) & 224);
        
        if (lightTypeMask != 0)
        {
            float3 lightPos = cb2[lightIndex_base + 0].xyz - worldPos;
            float lightRadiusSq_inv = cb2[lightIndex_base + 0].w * cb2[lightIndex_base + 0].w;
            float distToLightSq = dot(lightPos, lightPos);
            float lightAttenuation = distToLightSq * lightRadiusSq_inv;
            
            if (1.0 >= lightAttenuation)
            {
                float lightAttenFactor = saturate(lightAttenuation * 2.5 - 1.5);
                float lightAttenFresnel = (lightAttenFactor * -2.0 + 3.0) * (lightAttenFactor * lightAttenFactor) * -1.0 + 1.0;
                float rsqrtDistToLight = rsqrt(distToLightSq);
                float3 lightVec = lightPos * rsqrtDistToLight;
                float NdotL = dot(normalizedWorldNormal, lightVec);
                float shadowKernelTerm = (NdotL + 1.0) * 0.5 - (cb2[lightIndex_base + 5].w * 0.939999998);
                float shadowInvRange = 1.0 / (cb2[lightIndex_base + 5].w * 0.0600000024);
                float shadowFactor = saturate(shadowInvRange * shadowKernelTerm);
                float shadowFresnel = (shadowFactor * -2.0 + 3.0) * (shadowFactor * shadowFactor);
                shadowFactor = min(1.0, shadowFresnel);
                
                float3 shadowColor_base = cb2[lightIndex_base + 6].xyz * diffuseIBLBase.xyz;
                
                float3 shadowLerp = baseColor * cb2[lightIndex_base + 5].xyz - shadowColor_base;
                float3 shadowColor = shadowFactor * shadowLerp + shadowColor_base;
                shadowColor = cb2[lightDataIndex].xxx * shadowColor;
                
                float currentLightFalloff = distToLightSq * cb2[lightIndex_base + 4].x + cb2[lightIndex_base + 4].y;
                currentLightFalloff = 1.0 / (9.99999975e-05 + currentLightFalloff);
                currentLightFalloff = (currentLightFalloff - 1.0) * cb2[lightIndex_base + 4].z;
                currentLightFalloff = min(1.0, currentLightFalloff * currentLightFalloff);
                
                uint lightFlags = asuint(cb2[lightIndex_base + 1].w) >> 16;
                if ((lightFlags & 15) == 2)
                {
                    float spotFactor = dot(lightVec, cb2[lightIndex_base + 1].xyz);
                    spotFactor = saturate(cb2[lightIndex_base + 2].y * (spotFactor - cb2[lightIndex_base + 2].x));
                    spotFactor = spotFactor * spotFactor * spotFactor * spotFactor;
                    currentLightFalloff = spotFactor * currentLightFalloff;
                }
                
                float subsurf_final = (finalSubsurfTerm * saturate(NdotL * 0.5 + 0.5)) - finalSubsurfScatter;
                subsurf_final = cb2[lightIndex_base + 4].w * subsurf_final + finalSubsurfScatter;
                float3 lightColor_direct_base = cb2[lightIndex_base + 3].www * shadowColor;
                float3 lightColor_indirect = baseColor - lightColor_direct_base;
                float3 lightColor_direct = subsurf_final * lightColor_indirect + lightColor_direct_base;
                lightColor_direct = cb2[lightIndex_base + 3].xyz * lightColor_direct;
                
                float totalLightIntensity = cb2[lightIndex_base + 3].x + cb2[lightIndex_base + 3].y + cb2[lightIndex_base + 3].z + cb2[lightDataIndex].x;
                float lightIntensityFactor = saturate(10.0 * totalLightIntensity);
                float visibilityTerm = cb2[lightDataIndex].y * lightIntensityFactor;

                float3 finalLightColor_this_loop = lightColor_direct * currentLightFalloff;

                float falloff_delta = lightAttenFresnel - currentLightFalloff;
                currentLightFalloff = cb2[lightIndex_base + 6].w * falloff_delta + currentLightFalloff;
                lightAccumulator = finalLightColor_this_loop * lightLoopFalloff + lightAccumulator;
                visibilityTerm = 1.0 - (currentLightFalloff * visibilityTerm);
                lightLoopFalloff = visibilityTerm * lightLoopFalloff;
            }
        }
        lightLoopCounter = lightLoopCounter + 1;
    }
    
    float3 preSssLighting = lightLoopFalloff * indirectLightingResult + lightAccumulator;
    
    float3 sssColor = float3(0.0, 0.0, 0.0);
    float reprojected_fresnel = finalSubsurfTerm;
    
    float isNotEyeShadingModel = (isShadingModel_13 == 0.0) ? 1.0 : 0.0;
    if (isNotEyeShadingModel != 0.0)
    {
        float isSubsurfaceProfileModel = (temp_int_shading_id == 1) ? 1.0 : 0.0;
        
        float scatterRadius = isSubsurfaceProfileModel ? tex4.z : tex4.y;
        
        float3 viewVec = cb1[67].xyz - worldPos;
        float viewVecLengthInv = rsqrt(dot(viewVec, viewVec));
        viewVec = viewVec * viewVecLengthInv;
        float scatterRadiusClamped = saturate(scatterRadius - 0.100000001);
        scatterRadius = saturate(10.0 * scatterRadius);
        float scatterPower = scatterRadiusClamped * 2000.0 + 50.0;
        float scatterKernelSize = scatterRadiusClamped + scatterRadiusClamped;
        scatterRadius = cb0[0].x * scatterRadius;
        scatterRadius = scatterRadius * 0.800000012 + scatterKernelSize;
        
        float3x3 tangentToWorld;
        tangentToWorld[0] = cb1[20].xyz;
        tangentToWorld[1] = cb1[21].xyz;
        tangentToWorld[2] = cb1[22].xyz;
        float3 worldNormalFromTangent = mul(normalizedWorldNormal, tangentToWorld);
        
        bool useStaticLighting = ((float)asint(cb0[0].w) > 0.5f);
        viewVec = useStaticLighting ? float3(0.0, 0.0, 0.0) : viewVec;
        float3 lightDir = useStaticLighting ? float3(cb0[0].y, cb0[0].z, 0.5) : cb1[264].xyz;
        float3 sssNormal = useStaticLighting ? worldNormalFromTangent : normalizedWorldNormal;
        
        float NdotL_final = dot(lightDir, sssNormal);
        float LdotV = dot(lightDir, viewVec);
        float LdotV_remap = saturate((LdotV + LdotV));
        
        float schlick_final;
        if (useStaticLighting)
        {
            float wrap_diffuse = max(0.0, 0.8 - NdotL_final) * 1.5;
            float sss_term_from_cb133 = min(1.745329, max(0.0, cb1[133].x)) * 0.572958;

            float depth_falloff_base = max(0.0, depth);
            float depth_falloff_clamped = min(depth_falloff_base, 3000.0);
            float depth_falloff = (3000.0 - depth_falloff_clamped) * 0.000333;
            float depth_fresnel_base = depth_falloff * depth_falloff;
            depth_fresnel_base = depth_fresnel_base * depth_fresnel_base;
            float depth_fresnel = depth_fresnel_base * depth_falloff + (depth_falloff * 0.02);
            
            float depth_lerp_base = depth_fresnel - 1.0;
            float depth_lerp_final = sss_term_from_cb133 * depth_lerp_base + 1.0;
            float depth_and_radius_lerp = scatterRadiusClamped * (depth_lerp_final - 1.0) + 1.0;

            float LdotV_fresnel = (LdotV_remap * -2.0 + 3.0) * (LdotV_remap * LdotV_remap) + 1.0;
            float backscatter_factor = LdotV_remap * 0.5 + 0.5;
            
            schlick_final = wrap_diffuse * backscatter_factor;
            schlick_final *= depth_and_radius_lerp;
            schlick_final *= LdotV_fresnel;
            schlick_final *= 0.01;
        }
        else
        {
            float3 halfVec = normalize(lightDir + viewVec);
            float NdotH = saturate(dot(sssNormal, halfVec));
            float NdotH_sq = NdotH * NdotH;
            float specTerm = (NdotH_sq * -0.800000012 + 1.0);
            specTerm = specTerm * specTerm;
            specTerm = 0.200000003 / (3.14159274 * specTerm);
            specTerm = specTerm * scatterRadiusClamped;

            schlick_final = ( (0.400000006 * lightDir.y) * (NdotL_final * 0.800000012 + 0.200000003) + (1.5 * specTerm * NdotL_final) ) * (LdotV_remap * 0.5 + 0.5);
        }
        
        float2 worldNormalXY_sq_plus_eps = sssNormal.xy * sssNormal.xy + 9.99999975e-05;
        float rsqrt_normal_xy = rsqrt(dot(worldNormalXY_sq_plus_eps, float2(1.0, 1.0)));
        float2 normal_xy_normalized = sssNormal.xy * rsqrt_normal_xy;
        normal_xy_normalized = normal_xy_normalized * scatterRadius;
        
        float sss_lobe_y_component = schlick_final * normal_xy_normalized.y;
        float2 sss_lobes = float2(normal_xy_normalized.x * schlick_final, sss_lobe_y_component * -0.5);
        
        float2 uv_offset = (screenUV.xy * cb1[138].xy - cb1[134].xy) * cb1[135].zw + sss_lobes;
        float2 final_uv = (uv_offset * cb1[135].xy + cb1[134].xy) * cb1[138].zw;
        
        float reprojectedDepth_raw = tex2D(_IN6, final_uv).x;
        float reprojectedViewDepth_temp = reprojectedDepth_raw * cb1[65].x + cb1[65].y;
        reprojectedDepth_raw = 1.0 / (reprojectedDepth_raw * cb1[65].z - cb1[65].w);
        float reprojectedViewDepth = reprojectedViewDepth_temp + reprojectedDepth_raw;
        
        float depth_diff = max(9.99999975e-05, reprojectedViewDepth - depth);
        float reprojected_falloff = saturate((depth_diff - scatterRadiusClamped * 1000.0) / scatterPower);
        float reprojected_fresnel_temp = (reprojected_falloff * -2.0 + 3.0) * (reprojected_falloff * reprojected_falloff);
        reprojected_fresnel = min(1.0, reprojected_fresnel_temp);
        
        float ambient_luma = dot(cb1[263].xyz, float3(0.300000012, 0.589999974, 0.109999999));
        float3 ambient_color = (cb1[263].xyz - ambient_luma) * 0.75 + ambient_luma;
        ambient_color = reprojected_fresnel * (cb1[263].xyz - ambient_color) + ambient_color;
        ambient_color = ambient_color * scatterRadius;
        ambient_color = ambient_color * 0.100000001;
        float3 ambient_base = (1.0 + baseColor) * ambient_color;
        float3 spec_highlight_mask_arg = (baseColor * 1.20000005) - 1.0;
        float3 spec_highlight_mask = saturate(-spec_highlight_mask_arg);
        float3 spec_highlight_factor = (spec_highlight_mask * -2.0 + 3.0) * (spec_highlight_mask * spec_highlight_mask);
        spec_highlight_factor = spec_highlight_factor * 14.0 + 1.0;
        ambient_color = spec_highlight_factor * ambient_color;
        ambient_color = (ambient_color * baseColor) - ambient_base;
        ambient_color = cb1[260].zzz * ambient_color + ambient_base;
        ambient_color = ambient_color * reprojected_fresnel;
        
        float fog_factor = 0.000199999995 * (5000.0 - min(5000.0, max(0.0, depth - 10000.0)));
        ambient_color = fog_factor * ambient_color;
        sssColor = cb0[1].xyz * ambient_color;
    }
    
    float3 baseLighting = preSssLighting * initialLighting.xyz;
    baseLighting = cb1[263].xyz * baseLighting;
    baseLighting = (baseLighting * 0.5) - preSssLighting;
    baseLighting = reprojected_fresnel * baseLighting + preSssLighting;
    
    float3 finalCompositedColor = preSssLighting + sssColor;

    finalCompositedColor = bIsModel15 ? baseLighting : finalCompositedColor;

    float3 finalColorXYZ = isShadingModel_5 ? preSssLighting : finalCompositedColor;
    
    finalColorXYZ = finalColorXYZ / aoFactor;
    
    finalColorXYZ = min(float3(0.0, 0.0, 0.0), -finalColorXYZ);
    
    float4 finalColor;
    finalColor.xyz = -finalColorXYZ;
    finalColor.w = 0.0;
    
    return finalColor;
}
B:
float4 frag (VertexToFragment fragmentInput) : SV_Target
{
    float4 v0 = fragmentInput.uv; 

    float4 color = 0;
    
    float4 r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,r16;
    uint4 bitmask, uiDest;
    float4 fDest;

    r0.xyzw = tex2Dlod(_IN1, float4(v0.xy, 0, 0)).wxyz;
    r1.xyzw = tex2Dlod(_IN2, float4(v0.xy, 0, 0)).xyzw;
    r2.xyz = tex2Dlod(_IN3, float4(v0.xy, 0, 0)).xyz;
    r3.xyz = tex2Dlod(_IN4, float4(v0.xy, 0, 0)).yxz;
    r2.w = tex2Dlod(_IN0, float4(v0.xy, 0, 0)).x;
    r3.w = r2.w * cb1[65].x + cb1[65].y;
    r2.w = r2.w * cb1[65].z + -cb1[65].w;
    r2.w = 1 / r2.w;
    r2.w = r3.w + r2.w;
    r4.xy = cb1[138].xy * v0.xy;
    r4.xy = (uint2)r4.xy;
    r3.w = (uint)cb1[158].x;
    r4.x = (int)r4.y + (int)r4.x;
    r3.w = (int)r3.w + (int)r4.x;
    r3.w = (int)r3.w & 1;
    r1.w = 255 * r1.w;
    r1.w = round(r1.w);
    r1.w = (uint)r1.w;
    r4.xy = (int2)r1.ww & int2(15,-16);
    r1.w = ((int)r4.x != 12) ? 1.0 : 0.0;
    r5.xyz = ((int3)r4.xxx == int3(13,14,15)) ? 1.0 : 0.0;
    r4.z = (int)r5.z | (int)r5.y;
    r4.z = (int)r4.z | (int)r5.x;
    r1.w = r1.w ? r4.z : -1;
    if (r1.w != 0) {
        r4.x = r5.x ? 13 : 12;
        r5.xz = r5.yz ? float2(1,1) : 0;
        r4.zw = r0.yz * float2(2,2) + float2(-1,-1);
        r1.w = dot(float2(1,1), abs(r4.zw));
        r6.z = 1 + -r1.w;
        r1.w = max(0, -r6.z);
        r7.xy = (r4.zw >= float2(0,0)) ? 1.0 : 0.0;
        r7.xy = r7.xy ? float2(0.5,0.5) : float2(-0.5,-0.5);
        r7.xy = r7.xy * r1.ww;
        r6.xy = r7.xy * float2(-2,-2) + r4.zw;
        r1.w = dot(r6.xyz, r6.xyz);
        r1.w = rsqrt(r1.w);
        r6.xyz = r6.xyz * r1.www;
        r7.xyz = r1.xyz * r1.xyz;
        r5.y = r3.z;
    } else {
        r1.w = ((int)r4.x == 10) ? 1.0 : 0.0;
        r1.xyz = saturate(r1.xyz);
        r1.xyz = float3(16777215,65535,255) * r1.xyz;
        r1.xyz = round(r1.xyz);
        r1.xyz = (uint3)r1.xyz;
        bitmask.y = ((~(-1 << 8)) << 0) & 0xffffffff;  r1.y = (((uint)r1.z << 0) & bitmask.y) | ((uint)r1.y & ~bitmask.y);
        bitmask.x = ((~(-1 << 16)) << 0) & 0xffffffff;  r1.x = (((uint)r1.y << 0) & bitmask.x) | ((uint)r1.x & ~bitmask.x);
        r1.x = (uint)r1.x;
        r1.x = 5.96046519e-008 * r1.x;
        r1.y = r1.x * cb1[65].x + cb1[65].y;
        r1.x = r1.x * cb1[65].z + -cb1[65].w;
        r1.x = 1 / r1.x;
        r1.x = r1.y + r1.x;
        r2.w = r1.w ? r1.x : r2.w;
        r6.xyz = r0.yzw * float3(2,2,2) + float3(-1,-1,-1);
        r7.xyz = float3(0,0,0);
        r5.xyz = float3(0,0,0);
        r0.xw = float2(0,0);
        r3.xy = float2(0,0);
    }
    r0.y = dot(r6.xyz, r6.xyz);
    r0.y = rsqrt(r0.y);
    r1.xyz = r6.xyz * r0.yyy;
    r0.yz = ((int2)r4.xx == int2(5,13)) ? 1.0 : 0.0;
    r1.w = (0 < cb1[162].y) ? 1.0 : 0.0;
    r4.z = (0 < cb1[220].z) ? 1.0 : 0.0;
    r1.w = r1.w ? r4.z : 0;
    r4.z = (0 != cb1[162].y) ? 1.0 : 0.0;
    r6.xyz = r4.zzz ? float3(1,1,1) : r2.xyz;
    r3.w = r3.w ? 1 : 0;
    r6.xyz = r1.www ? r3.www : r6.xyz;
    r2.xyz = r0.yyy ? r6.xyz : r2.xyz;
    r0.y = tex2Dlod(_IN9, float4(0, 0, 0, 0)).x;
    r4.zw = v0.zw * r2.ww; // 此处的v0.zw根据前面的定义将为0
    r6.xyz = cb1[49].xyz * r4.www;
    r6.xyz = r4.zzz * cb1[48].xyz + r6.xyz;
    r6.xyz = r2.www * cb1[50].xyz + r6.xyz;
    r6.xyz = cb1[51].xyz + r6.xyz;
    r4.zw = tex2Dlod(_IN5, float4(v0.xy, 0, 0)).xz;
    r4.zw = r4.zw * r4.zw;
    r1.w = r4.z * r4.w;
    r3.w = cb1[253].y * r1.w;
    if (cb1[255].x != 0) {
        r8.xyz = float3(0,0,0);
        r4.zw = float2(0,0);
        r5.w = 0;
        r6.w = 0;
        while (true) {
        r7.w = ((int)r4.z >= 3) ? 1.0 : 0.0;
        if (r7.w != 0) break;
        r4.w = 0.000833333295 + r4.w;
        r9.xyz = r8.xyz;
        r7.w = r5.w;
        r8.w = r6.w;
        r9.w = 0;
        while (true) {
            r10.x = ((int)r9.w >= 3) ? 1.0 : 0.0;
            if (r10.x != 0) break;
            r7.w = 1 + r7.w;
            r10.x = 2.09439516 * r7.w;
            sincos(r10.x, r10.x, r11.x);
            r11.x = r11.x * r4.w + v0.x;
            r11.y = r10.x * r4.w + v0.y;
            r10.xyz = tex2D(_IN7, r11.xy).xyz;
            r9.xyz = r10.xyz * r4.www + r9.xyz;
            r8.w = r8.w + r4.w;
            r9.w = (int)r9.w + 1;
        }
        r8.xyz = r9.xyz;
        r6.w = r8.w;
        r5.w = 0.620000005 + r7.w;
        r4.z = (int)r4.z + 1;
        }
        r8.xyz = r8.xyz / r6.www;
        r9.xyz = (float3(0.644999981,0.312000006,0.978999972) < r0.xxx) ? 1.0 : 0.0;
        r10.xyz = (r0.xxx < float3(0.685000002,0.351999998,1.02100003)) ? 1.0 : 0.0;
        r9.xyz = r9.xyz ? r10.xyz : 0;
        r0.x = r9.z ? 1.000000 : 0;
        r0.x = r9.y ? 0 : r0.x;
        r0.x = r9.x ? 1 : r0.x;
        r4.z = (int)r9.y | (int)r9.z;
        r4.z = (int)r4.z & 0x3f800000;
        r4.z = r9.x ? 0 : r4.z;
        r3.x = 255 * r3.x;
        r3.x = round(r3.x);
        r3.x = (uint)r3.x;
        r9.xyzw = (int4)r3.xxxx & int4(15,240,240,15);
        r9.xyzw = (uint4)r9.xyzw;
        r3.x = saturate(r0.w + r0.w);
        r4.w = r3.x * -2 + 3;
        r3.x = r3.x * r3.x;
        r3.x = r4.w * r3.x;
        r4.w = -0.5 + r0.w;
        r4.w = saturate(r4.w + r4.w);
        r5.w = r4.w * -2 + 3;
        r4.w = r4.w * r4.w;
        r4.w = r5.w * r4.w;
        r10.xyz = cb1[262].xyz + -cb1[261].xyz;
        r5.w = dot(abs(r10.xyz), float3(0.300000012,0.589999974,0.109999999));
        r5.w = 10 * r5.w;
        r5.w = min(1, r5.w);
        r6.w = r5.w * -2 + 3;
        r5.w = r5.w * r5.w;
        r5.w = r6.w * r5.w;
        r6.w = r5.w * r4.w;
        r7.w = cb1[265].y + -cb1[265].x;
        r8.w = r1.w * cb1[253].y + -cb1[265].x;
        r7.w = 1 / r7.w;
        r8.w = saturate(r8.w * r7.w);
        r10.x = r8.w * -2 + 3;
        r8.w = r8.w * r8.w;
        r8.w = r10.x * r8.w;
        r8.w = r8.w * r6.w;
        r10.x = r1.w * cb1[253].y + -r8.w;
        r8.w = cb1[265].z * r10.x + r8.w;
        r10.x = -cb1[265].x + r8.w;
        r7.w = saturate(r10.x * r7.w);
        r10.x = r7.w * -2 + 3;
        r7.w = r7.w * r7.w;
        r7.w = r10.x * r7.w;
        r6.w = r7.w * r6.w;
        r4.w = r4.w * r5.w + -r6.w;
        r4.w = cb1[265].z * r4.w + r6.w;
        r5.w = -1 + r8.w;
        r5.w = cb1[260].y * r5.w + 1;
        r6.w = r3.w * r4.w + -r5.w;
        r5.w = r5.x * r6.w + r5.w;
        r6.w = r3.w * r4.w + -r4.w;
        r10.x = r5.x * r6.w + r4.w;
        r4.w = (r8.y >= r8.z) ? 1.0 : 0.0;
        r4.w = r4.w ? 1.000000 : 0;
        r11.xy = r8.zy;
        r11.zw = float2(-1,0.666666687);
        r12.xy = -r11.xy + r8.yz;
        r12.zw = float2(1,-1);
        r11.xyzw = r4.wwww * r12.xyzw + r11.xyzw;
        r4.w = (r8.x >= r11.x) ? 1.0 : 0.0;
        r4.w = r4.w ? 1.000000 : 0;
        r12.xyz = r11.xyw;
        r12.w = r8.x;
        r11.xyw = r12.wyx;
        r11.xyzw = r11.xyzw + -r12.xyzw;
        r11.xyzw = r4.wwww * r11.xyzw + r12.xyzw;
        r4.w = min(r11.w, r11.y);
        r4.w = r11.x + -r4.w;
        r6.w = r11.w + -r11.y;
        r7.w = r4.w * 6 + 0.00100000005;
        r6.w = r6.w / r7.w;
        r6.w = r11.z + r6.w;
        r7.w = 0.00100000005 + r11.x;
        r4.w = r4.w / r7.w;
        r7.w = r11.x * 0.300000012 + 1;
        r11.xyzw = r9.xyzw * float4(0.0400000028,0.0027450982,0.00392156886,0.0666666701) + float4(0.400000006,0.400000006,1,0.5);
        r8.w = (r9.z >= 2.54999971) ? 1.0 : 0.0;
        r8.w = r8.w ? 1.000000 : 0;
        r9.x = r11.y + -r11.x;
        r9.x = r8.w * r9.x + r11.x;
        r4.w = r9.x * r4.w;
        r4.w = min(0.349999994, r4.w);
        r9.x = max(0, r4.w);
        r9.yzw = float3(1,0.666666687,0.333333343) + abs(r6.www);
        r9.yzw = frac(r9.yzw);
        r9.yzw = r9.yzw * float3(6,6,6) + float3(-3,-3,-3);
        r9.yzw = saturate(float3(-1,-1,-1) + abs(r9.yzw));
        r9.yzw = float3(-1,-1,-1) + r9.yzw;
        r9.xyz = r9.xxx * r9.yzw + float3(1,1,1);
        r4.w = 1 + r4.w;
        r12.xyz = r9.xyz * r4.www;
        r13.xyz = r9.xyz * r4.www + float3(-1,-1,-1);
        r13.xyz = r13.xyz * float3(0.600000024,0.600000024,0.600000024) + float3(1,1,1);
        r9.xyz = -r9.xyz * r4.www + r13.xyz;
        r9.xyz = r0.xxx * r9.xyz + r12.xyz;
        r12.xyz = r9.xyz + -r2.xyz;
        r12.xyz = r12.xyz * float3(0.850000024,0.850000024,0.850000024) + r2.xyz;
        r11.xyz = r11.zzz * r12.xyz + -r9.xyz;
        r9.xyz = r8.www * r11.xyz + r9.xyz;
        r9.xyz = float3(-1,-1,-1) + r9.xyz;
        r9.xyz = r11.www * r9.xyz + float3(1,1,1);
        r11.xyz = float3(0.200000003,0.200000003,0.200000003) * cb1[261].xyz;
        r12.xyz = cb1[262].xyz * float3(0.5,0.5,0.5) + -r11.xyz;
        r11.xyz = r5.www * r12.xyz + r11.xyz;
        r11.xyz = cb1[260].xxx * r11.xyz;
        r11.xyz = r11.xyz * r2.xyz;
        r12.xyz = r11.xyz * r7.xyz;
        r13.xyz = cb1[261].xyz * r2.xyz;
        r0.x = r3.x * 0.300000012 + 0.699999988;
        r14.xyz = r13.xyz * r0.xxx;
        r15.xyz = cb1[262].xyz * r2.xyz;
        r12.xyz = r13.xyz * r0.xxx + r12.xyz;
        r13.xyz = r2.xyz * cb1[262].xyz + -r14.xyz;
        r13.xyz = r13.xyz * float3(0.400000006,0.400000006,0.400000006) + r14.xyz;
        r16.xyz = r14.xyz * r9.xyz;
        r13.xyz = r13.xyz * r9.xyz + -r16.xyz;
        r13.xyz = r10.xxx * r13.xyz + r16.xyz;
        r11.xyz = r11.xyz * r7.xyz + r13.xyz;
        r12.xyz = r12.xyz * r9.xyz;
        r13.xyz = r15.xyz * r7.www;
        r9.xyz = r13.xyz * r9.xyz + -r12.xyz;
        r9.xyz = r10.xxx * r9.xyz + r12.xyz;
        r0.x = tex2Dlod(_IN8, float4(v0.xy, 0, 0)).x;
        r0.x = -1 + r0.x;
        r0.x = r4.z * r0.x + 1;
        r9.xyz = r9.xyz + -r11.xyz;
        r9.xyz = r5.www * r9.xyz + r11.xyz;
        r11.xyz = float3(1,1,1) + -r8.xyz;
        r8.xyz = r0.xxx * r11.xyz + r8.xyz;
        r8.xyz = r9.xyz * r8.xyz;
    } else {
        r0.x = saturate(r0.w + r0.w);
        r3.x = r0.x * -2 + 3;
        r0.x = r0.x * r0.x;
        r0.x = r3.x * r0.x;
        r3.x = -0.5 + r0.w;
        r3.x = saturate(r3.x + r3.x);
        r4.z = r3.x * -2 + 3;
        r3.x = r3.x * r3.x;
        r3.x = r4.z * r3.x;
        r9.xyz = cb1[262].xyz + -cb1[261].xyz;
        r4.z = dot(abs(r9.xyz), float3(0.300000012,0.589999974,0.109999999));
        r4.z = 10 * r4.z;
        r4.z = min(1, r4.z);
        r4.w = r4.z * -2 + 3;
        r4.z = r4.z * r4.z;
        r4.z = r4.w * r4.z;
        r4.w = r4.z * r3.x;
        r5.w = cb1[265].y + -cb1[265].x;
        r6.w = r1.w * cb1[253].y + -cb1[265].x;
        r5.w = 1 / r5.w;
        r6.w = saturate(r6.w * r5.w);
        r7.w = r6.w * -2 + 3;
        r6.w = r6.w * r6.w;
        r6.w = r7.w * r6.w;
        r6.w = r6.w * r4.w;
        r1.w = r1.w * cb1[253].y + -r6.w;
        r1.w = cb1[265].z * r1.w + r6.w;
        r6.w = -cb1[265].x + r1.w;
        r5.w = saturate(r6.w * r5.w);
        r6.w = r5.w * -2 + 3;
        r5.w = r5.w * r5.w;
        r5.w = r6.w * r5.w;
        r4.w = r5.w * r4.w;
        r3.x = r3.x * r4.z + -r4.w;
        r3.x = cb1[265].z * r3.x + r4.w;
        r4.z = r1.w * r5.y;
        r4.z = 10 * r4.z;
        r1.w = -1 + r1.w;
        r1.w = cb1[260].y * r1.w + 1;
        r4.w = r3.w * r3.x + -r1.w;
        r1.w = r5.x * r4.w + r1.w;
        r4.w = r3.w * r3.x + -r3.x;
        r10.x = r5.x * r4.w + r3.x;
        r5.xyw = float3(0.200000003,0.200000003,0.200000003) * cb1[261].xyz;
        r9.xyz = cb1[262].xyz * float3(0.5,0.5,0.5) + -r5.xyw;
        r5.xyw = r1.www * r9.xyz + r5.xyw;
        r5.xyw = cb1[260].xxx * r5.xyw;
        r5.xyw = r5.xyw * r2.xyz;
        r9.xyz = r5.xyw * r7.xyz;
        r11.xyz = cb1[261].xyz * r2.xyz;
        r0.x = r0.x * 0.300000012 + 0.699999988;
        r14.xyz = r11.xyz * r0.xxx;
        r11.xyz = r11.xyz * r0.xxx + r9.xyz;
        r9.xyz = r9.xyz * r4.zzz + r11.xyz;
        r11.xyz = r2.xyz * cb1[262].xyz + -r14.xyz;
        r11.xyz = r11.xyz * r10.xxx;
        r11.xyz = r11.xyz * float3(0.400000006,0.400000006,0.400000006) + r14.xyz;
        r5.xyw = r5.xyw * r7.xyz + r11.xyz;
        r11.xyz = r2.xyz * cb1[262].xyz + -r9.xyz;
        r9.xyz = r10.xxx * r11.xyz + r9.xyz;
        r9.xyz = r9.xyz + -r5.xyw;
        r8.xyz = r1.www * r9.xyz + r5.xyw;
    }
    r0.x = -0.400000006 + r0.w;
    r0.x = saturate(10.000001 * r0.x);
    r0.w = r0.x * -2 + 3;
    r0.x = r0.x * r0.x;
    r10.y = r0.w * r0.x;
    r5.xyw = r8.xyz * float3(0.5,0.5,0.5) + cb1[261].xyz;
    r5.xyw = r5.xyw * r2.xyz;
    r9.xyz = cb1[261].xyz * r2.xyz;
    r5.xyw = cb1[255].xxx ? r5.xyw : r9.xyz;
    r9.xyz = r0.zzz ? r5.xyw : r14.xyz;
    r5.xyw = r0.zzz ? r5.xyw : r8.xyz;
    r0.xw = r0.zz ? float2(0,0) : r10.xy;
    r8.xyz = cb1[264].xyz + cb1[264].xyz;
    r8.xyz = r0.xxx * r8.xyz + -cb1[264].xyz;
    r10.xyz = float3(0,0,0);
    r1.w = 1;
    r3.x = 0;
    while (true) {
        r4.z = ((uint)r3.x >= asuint(cb2[128].x)) ? 1.0 : 0.0;
        if (r4.z != 0) break;
        bitmask.z = ((~(-1 << 29)) << 3) & 0xffffffff;  r4.z = (((uint)r3.x << 3) & bitmask.z) | ((uint)7 & ~bitmask.z);
        bitmask.w = ((~(-1 << 3)) << 5) & 0xffffffff;  r4.w = (((uint)cb2[r4.z+0].w << 5) & bitmask.w) | ((uint)0 & ~bitmask.w);
        r4.w = (int)r4.y & (int)r4.w;
        if (r4.w == 0) {
        r4.w = (int)r3.x + 1;
        r3.x = r4.w;
        continue;
        }
        r4.w = (uint)r3.x << 3;
        r11.xyz = cb2[r4.w+0].xyz + -r6.xyz;
        r6.w = cb2[r4.w+0].w * cb2[r4.w+0].w;
        r7.w = dot(r11.xyz, r11.xyz);
        r6.w = r7.w * r6.w;
        r8.w = (1 >= r6.w) ? 1.0 : 0.0;
        if (r8.w != 0) {
        bitmask.x = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.x = (((uint)r3.x << 3) & bitmask.x) | ((uint)1 & ~bitmask.x);
        bitmask.y = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.y = (((uint)r3.x << 3) & bitmask.y) | ((uint)2 & ~bitmask.y);
        bitmask.z = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.z = (((uint)r3.x << 3) & bitmask.z) | ((uint)3 & ~bitmask.z);
        bitmask.w = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.w = (((uint)r3.x << 3) & bitmask.w) | ((uint)4 & ~bitmask.w);
        bitmask.x = ((~(-1 << 29)) << 3) & 0xffffffff;  r13.x = (((uint)r3.x << 3) & bitmask.x) | ((uint)5 & ~bitmask.x);
        bitmask.y = ((~(-1 << 29)) << 3) & 0xffffffff;  r13.y = (((uint)r3.x << 3) & bitmask.y) | ((uint)6 & ~bitmask.y);
        r6.w = saturate(r6.w * 2.5 + -1.5);
        r8.w = r6.w * r6.w;
        r6.w = -r6.w * 2 + 3;
        r6.w = -r8.w * r6.w + 1;
        r7.w = rsqrt(r7.w);
        r14.xyz = r11.xyz * r7.www;
        r7.w = dot(r1.xyz, r14.xyz);
        r7.w = 1 + r7.w;
        r13.zw = cb2[r13.x+0].ww * float2(0.939999998,0.0600000024);
        r7.w = r7.w * 0.5 + -r13.z;
        r8.w = 1 / r13.w;
        r7.w = saturate(r8.w * r7.w);
        r8.w = r7.w * -2 + 3;
        r7.w = r7.w * r7.w;
        r7.w = r8.w * r7.w;
        r7.w = min(1, r7.w);
        r15.xyz = cb2[r13.y+0].xyz * r9.xyz;
        r13.xzw = r2.xyz * cb2[r13.x+0].xyz + -r15.xyz;
        r13.xzw = r7.www * r13.xzw + r15.xyz;
        r13.xzw = cb2[r4.z+0].xxx * r13.xzw;
        r11.xyz = cb2[r4.w+0].www * r11.xyz;
        r4.w = dot(r11.xyz, r11.xyz);
        r4.w = r4.w * cb2[r12.w+0].x + cb2[r12.w+0].y;
        r4.w = 9.99999975e-005 + r4.w;
        r4.w = 1 / r4.w;
        r4.w = -1 + r4.w;
        r4.w = cb2[r12.w+0].z * r4.w;
        r4.w = r4.w * r4.w;
        r4.w = min(1, r4.w);
        if (4 == 0) r7.w = 0; else if (4+16 < 32) {       r7.w = (uint)cb2[r12.x+0].w << (32-(4 + 16)); r7.w = (uint)r7.w >> (32-4);      } else r7.w = (uint)cb2[r12.x+0].w >> 16;
        r7.w = ((int)r7.w == 2) ? 1.0 : 0.0;
        r8.w = dot(r14.xyz, cb2[r12.x+0].xyz);
        r8.w = -cb2[r12.y+0].x + r8.w;
        r8.w = saturate(cb2[r12.y+0].y * r8.w);
        r8.w = r8.w * r8.w;
        r8.w = r8.w * r8.w;
        r8.w = r8.w * r4.w;
        r4.w = r7.w ? r8.w : r4.w;
        r7.w = dot(r8.xyz, r14.xyz);
        r7.w = saturate(r7.w * 0.5 + 0.5);
        r7.w = r0.w * r7.w + -r0.x;
        r7.w = cb2[r12.w+0].w * r7.w + r0.x;
        r11.xyz = cb2[r12.z+0].www * r9.xyz;
        r12.xyw = -r9.xyz * cb2[r12.z+0].www + r2.xyz;
        r11.xyz = r7.www * r12.xyw + r11.xyz;
        r11.xyz = cb2[r12.z+0].xyz * r11.xyz;
        r7.w = cb2[r12.z+0].x + cb2[r12.z+0].y;
        r7.w = cb2[r12.z+0].z + r7.w;
        r7.w = cb2[r4.z+0].x + r7.w;
        r7.w = saturate(10 * r7.w);
        r4.z = cb2[r4.z+0].y * r7.w;
        r12.xyz = r13.xzw * r4.www;
        r11.xyz = r11.xyz * r4.www + r12.xyz;
        r6.w = r6.w + -r4.w;
        r4.w = cb2[r13.y+0].w * r6.w + r4.w;
        r10.xyz = r11.xyz * r1.www + r10.xyz;
        r4.z = -r4.w * r4.z + 1;
        r1.w = r4.z * r1.w;
        }
        r3.x = (int)r3.x + 1;
    }
    r4.yzw = r1.www * r5.xyw + r10.xyz;
    r0.x = ((int)r4.x != 13) ? 1.0 : 0.0;
    if (r0.x != 0) {
        r0.x = ((int)r4.x == 1) ? 1.0 : 0.0;
        r0.x = r0.x ? r3.z : r3.y;
        r3.xyz = cb1[67].xyz + -r6.xyz;
        r0.w = dot(r3.xyz, r3.xyz);
        r0.w = rsqrt(r0.w);
        r3.xyz = r3.xyz * r0.www;
        r0.w = saturate(-0.100000001 + r0.x);
        r0.x = saturate(10 * r0.x);
        r1.w = r0.w * 2000 + 50;
        r4.x = r0.w + r0.w;
        r0.x = cb0[0].x * r0.x;
        r0.x = r0.x * 0.800000012 + r4.x;
        r5.xyw = cb1[21].xyz * r1.yyy;
        r5.xyw = r1.xxx * cb1[20].xyz + r5.xyw;
        r5.xyw = r1.zzz * cb1[22].xyz + r5.xyw;
        r4.x = asint(cb0[0].w);
        r4.x = (0.5 < r4.x) ? 1.0 : 0.0;
        r3.xyz = r4.xxx ? float3(0,0,0) : r3.xyz;
        r6.xy = r4.xx ? cb0[0].yz : cb1[264].xy;
        r6.z = r4.x ? 0.5 : cb1[264].z;
        r1.xyz = r4.xxx ? r5.xyw : r1.xyz;
        r4.x = dot(r6.xyz, r1.xyz);
        r8.xy = float2(0.200000003,1) + r4.xx;
        r4.x = 5 * r8.x;
        r4.x = saturate(r4.x);
        r5.w = r4.x * -2 + 3;
        r4.x = r4.x * r4.x;
        r4.x = r5.w * r4.x;
        r8.xzw = r6.xyz + r3.xyz;
        r5.w = dot(r8.xzw, r8.xzw);
        r5.w = rsqrt(r5.w);
        r8.xzw = r8.xzw * r5.www;
        r5.w = saturate(dot(r1.xyz, r8.xzw));
        r5.w = r5.w * r5.w;
        r5.w = r5.w * -0.800000012 + 1;
        r5.w = r5.w * r5.w;
        r5.w = 3.14159274 * r5.w;
        r5.w = 0.200000003 / r5.w;
        r5.w = r5.w * r3.w;
        r6.x = dot(r6.xyz, r3.xyz);
        r6.xy = float2(-0.5,1) + -r6.xx;
        r6.x = saturate(r6.x + r6.x);
        r6.z = r6.x * -2 + 3;
        r6.x = r6.x * r6.x;
        r6.x = r6.z * r6.x + 1;
        r1.x = saturate(dot(r3.xyz, r1.xyz));
        r1.x = 0.800000012 + -r1.x;
        r1.x = max(0, r1.x);
        r1.y = max(0, cb1[133].x);
        r1.y = min(1.74532926, r1.y);
        r1.xy = float2(1.5,0.572957814) * r1.xy;
        r1.z = max(0, r2.w);
        r3.xy = min(float2(3000,50), r1.zz);
        r3.xy = float2(3000,50) + -r3.xy;
        r3.xy = float2(0.00033333333,0.0199999996) * r3.xy;
        r1.z = r3.x * r3.x;
        r1.z = r1.z * r1.z;
        r1.z = r1.z * r1.z + r3.y;
        r1.z = -1 + r1.z;
        r1.y = r1.y * r1.z + 1;
        r1.z = 1 + -r1.y;
        r1.y = r0.w * r1.z + r1.y;
        r1.z = r8.y * 0.25 + 0.5;
        r1.x = r1.z * r1.x;
        r1.x = r1.x * r1.y;
        r1.x = r1.x * r6.x;
        r1.x = 0.00999999978 * r1.x;
        r3.xy = float2(9.99999975e-005,9.99999975e-005) + r5.xy;
        r1.z = dot(r3.xy, r3.xy);
        r1.z = rsqrt(r1.z);
        r3.xy = r3.xy * r1.zz;
        r3.xy = r3.xy * r0.xx;
        r3.z = r3.y * r1.x;
        r1.y = -0.5;
        r1.xy = r3.xz * r1.xy;
        r0.x = 0.400000006 * r6.y;
        r1.z = r4.x * 0.800000012 + 0.200000003;
        r3.x = r5.w * r4.x;
        r3.x = 1.5 * r3.x;
        r0.x = r0.x * r1.z + r3.x;
        r1.z = r3.w * 0.5 + 0.5;
        r0.x = r1.z * r0.x;
        r3.xy = v0.xy * cb1[138].xy + -cb1[134].xy;
        r1.xy = r3.xy * cb1[135].zw + r1.xy;
        r1.xy = r1.xy * cb1[135].xy + cb1[134].xy;
        r1.xy = cb1[138].zw * r1.xy;
        r1.x = tex2D(_IN6, r1.xy).x;
        r1.y = r1.x * cb1[65].x + cb1[65].y;
        r1.x = r1.x * cb1[65].z + -cb1[65].w;
        r1.x = 1 / r1.x;
        r1.x = r1.y + r1.x;
        r1.x = r1.x + -r2.w;
        r1.x = max(9.99999975e-005, r1.x);
        r0.w = -r0.w * 1000 + r1.x;
        r1.x = 1 / r1.w;
        r0.w = saturate(r1.x * r0.w);
        r1.x = r0.w * -2 + 3;
        r0.w = r0.w * r0.w;
        r0.w = r1.x * r0.w;
        r0.w = min(1, r0.w);
        r1.x = dot(cb1[263].xyz, float3(0.300000012,0.589999974,0.109999999));
        r1.yzw = cb1[263].xyz + -r1.xxx;
        r1.xyz = r1.yzw * float3(0.75,0.75,0.75) + r1.xxx;
        r3.xyz = cb1[263].xyz + -r1.xyz;
        r1.xyz = r3.www * r3.xyz + r1.xyz;
        r1.xyz = r1.xyz * r0.xxx;
        r1.xyz = float3(0.100000001,0.100000001,0.100000001) * r1.xyz;
        r3.xyz = float3(1,1,1) + r2.xyz;
        r3.xyz = r3.xyz * r1.xyz;
        r5.xyw = r2.xyz * float3(1.20000005,1.20000005,1.20000005) + float3(-1,-1,-1);
        r5.xyw = saturate(-r5.xyw);
        r6.xyz = r5.xyw * float3(-2,-2,-2) + float3(3,3,3);
        r5.xyw = r5.xyw * r5.xyw;
        r5.xyw = r6.xyz * r5.xyw;
        r5.xyw = r5.xyw * float3(14,14,14) + float3(1,1,1);
        r1.xyz = r5.xyw * r1.xyz;
        r1.xyz = r1.xyz * r2.xyz + -r3.xyz;
        r1.xyz = cb1[260].zzz * r1.xyz + r3.xyz;
        r1.xyz = r1.xyz * r0.www;
        r0.x = -10000 + r2.w;
        r0.x = max(0, r0.x);
        r0.x = min(5000, r0.x);
        r0.x = 5000 + -r0.x;
        r0.x = 0.000199999995 * r0.x;
        r1.xyz = r0.xxx * r1.xyz;
        r1.xyz = cb0[1].xyz * r1.xyz;
    } else {
        r1.xyz = float3(0,0,0);
    }
    r0.x = (0 != r5.z) ? 1.0 : 0.0;
    r2.xyz = r4.yzw * r7.xyz;
    r2.xyz = cb1[263].xyz * r2.xyz;
    r2.xyz = r2.xyz * float3(0.5,0.5,0.5) + -r4.yzw;
    r2.xyz = r0.www * r2.xyz + r4.yzw;
    r1.xyz = r4.yzw + r1.xyz;
    r1.xyz = r0.xxx ? r2.xyz : r1.xyz;
    r0.xzw = r0.zzz ? r4.yzw : r1.xyz;
    r0.xyz = r0.xzw / r0.yyy;
    r0.xyz = min(float3(0,0,0), -r0.xyz);
    color.xyz = -r0.xyz;
    return color;
}