角色设定 (Persona):
你是一位顶级的国家首席图形程序员和着色器逆向工程专家。你精通HLSL、渲染管线以及编译器如何将高级着色器代码转换为汇编指令。你的核心能力是精确分析和复现复杂的着色器逻辑。
任务指令 (Your Task):
仔细分析下面提供的所有代码（A, B）。
A是重命名后的结果 B是正确源码编译结果
识别出代码A中所有与代码B不一致的逻辑错误。
禁止省略任何代码。请为我提供一份完整、准确、可以直接编译的、已修复的代码A。
这份修复后的代码必须严格遵循代码D的逻辑流程，目标是实现与B源码的编译等价性,不能使用unroll 不能添加注释 不能把A的代码直接替换为B的代码或命名来解决问题。

A:float4 frag (VertexToFragment fragmentInput) : SV_Target
{
    // 基于输入uv定义uvAndNDC，zw分量是NDC x（clip.x / clip.w）并复制到 zw
    float4 uvAndNDC = fragmentInput.uv; 

    float4 color = 0;
    
    // 临时寄存器 r0-r16 的声明已被移除。
    // 其功能将由以下具有明确上下文含义的局部变量代替。
    uint4 bitmask, uiDest;
    float4 fDest;

    float4 gBufferA_WYZX = tex2Dlod(_IN1, float4(uvAndNDC.xy, 0, 0)).wxyz;
    float4 gBufferB = tex2Dlod(_IN2, float4(uvAndNDC.xy, 0, 0));
    float3 albedo = tex2Dlod(_IN3, float4(uvAndNDC.xy, 0, 0)).xyz;
    float3 gBufferD_YXZ = tex2Dlod(_IN4, float4(uvAndNDC.xy, 0, 0)).yxz;
    float sceneDepth = tex2Dlod(_IN0, float4(uvAndNDC.xy, 0, 0)).x;
    float viewDepth_intermediate = sceneDepth * cb1[65].x + cb1[65].y;
    float linearEyeDepth_denominator = sceneDepth * cb1[65].z - cb1[65].w;
    float inv_linearEyeDepth_denominator = 1.0f / linearEyeDepth_denominator;
    float linearEyeDepth = viewDepth_intermediate + inv_linearEyeDepth_denominator;
    float2 screenCoord_unscaled = cb1[138].xy * uvAndNDC.xy;
    uint2 screenCoord_int = (uint2)screenCoord_unscaled;
    uint ditherFrameConst = (uint)cb1[158].x;
    int ditherSeed_base = (int)screenCoord_int.y + (int)screenCoord_int.x;
    int ditherSeed_final = (int)ditherFrameConst + ditherSeed_base;
    int checkerboardPattern = ditherSeed_final & 1;
    float shadingModelID_encoded = 255.0f * gBufferB.w;
    float shadingModelID_rounded = round(shadingModelID_encoded);
    uint shadingModelID = (uint)shadingModelID_rounded;
    int2 shadingModelFlags = (int2)shadingModelID & int2(15, -16);
    float isNotFoliageFlag = ((int)shadingModelFlags.x != 12) ? 1.0f : 0.0f;
    float3 isClothHairEye_flags = ((int3)shadingModelFlags.x == int3(13, 14, 15)) ? 1.0f : 0.0f;
    int isHairOrEye_flag = (int)isClothHairEye_flags.z | (int)isClothHairEye_flags.y;
    int isClothHairOrEye_flag = isHairOrEye_flag | (int)isClothHairEye_flags.x;
    float specialShadingPath_flag = isNotFoliageFlag ? (float)isClothHairOrEye_flag : -1.0f;
    
    // 声明将在 if/else 块内外使用的变量
    float3 worldNormal;
    float3 materialParams_squared;
    float gBufferD_Z_copy;
    float2 shadingModel_flag_copies;
    float finalLinearEyeDepth;

    if (specialShadingPath_flag != 0.0f) {
        int selectedShadingModelID = isClothHairEye_flags.x ? 13 : 12;
        bool isHairOrEye_bool = isClothHairEye_flags.y || isClothHairEye_flags.z;
        shadingModel_flag_copies = isHairOrEye_bool ? float2(1.0f, 1.0f) : 0.0f;
        float2 unpackedNormal_pre = gBufferA_WYZX.yz * 2.0f - 1.0f;
        float sumAbsUnpackedNormal = dot(float2(1.0f, 1.0f), abs(unpackedNormal_pre));
        float reconstructedNormalZ_oct = 1.0f - sumAbsUnpackedNormal;
        float octNormal_correctionFactor = max(0.0f, -reconstructedNormalZ_oct);
        float2 octNormal_sign = (unpackedNormal_pre >= 0.0f) ? 1.0f : 0.0f;
        float2 octNormal_decodeBias = octNormal_sign ? float2(0.5f, 0.5f) : float2(-0.5f, -0.5f);
        float2 octNormal_scaledDecodeBias = octNormal_decodeBias * octNormal_correctionFactor;
        float2 reconstructedNormalXY_oct = octNormal_scaledDecodeBias * -2.0f + unpackedNormal_pre;
        float3 reconstructedNormal_oct = float3(reconstructedNormalXY_oct, reconstructedNormalZ_oct);
        float reconstructedNormal_lenSq = dot(reconstructedNormal_oct, reconstructedNormal_oct);
        float invLen_reconstructedNormal = rsqrt(reconstructedNormal_lenSq);
        worldNormal = reconstructedNormal_oct * invLen_reconstructedNormal;
        materialParams_squared = gBufferB.xyz * gBufferB.xyz;
        gBufferD_Z_copy = gBufferD_YXZ.z;
        finalLinearEyeDepth = linearEyeDepth; // 保持状态一致
    } else {
        float isClearCoatFlag = ((int)shadingModelFlags.x == 10) ? 1.0f : 0.0f;
        float3 materialParams_clamped = saturate(gBufferB.xyz);
        float3 materialParams_encoded = float3(16777215.0f, 65535.0f, 255.0f) * materialParams_clamped;
        uint3 materialParams_encoded_rounded = (uint3)round(materialParams_encoded);
        bitmask.y = ((~(-1 << 8)) << 0) & 0xffffffff;  uint packedDataY = (((uint)materialParams_encoded_rounded.z << 0) & bitmask.y) | ((uint)materialParams_encoded_rounded.y & ~bitmask.y);
        bitmask.x = ((~(-1 << 16)) << 0) & 0xffffffff;  uint packedDataX = (((uint)packedDataY << 0) & bitmask.x) | ((uint)materialParams_encoded_rounded.x & ~bitmask.x);
        uint finalPackedData = (uint)packedDataX;
        float decodedDepthFromPacking = 5.96046519e-008f * finalPackedData;
        float linearDepthFromPacking_part1 = decodedDepthFromPacking * cb1[65].x + cb1[65].y;
        float linearDepthFromPacking_part2 = decodedDepthFromPacking * cb1[65].z - cb1[65].w;
        float inv_linearDepthFromPacking_part2 = 1.0f / linearDepthFromPacking_part2;
        float linearDepthFromPacking = linearDepthFromPacking_part1 + inv_linearDepthFromPacking_part2;
        finalLinearEyeDepth = isClearCoatFlag ? linearDepthFromPacking : linearEyeDepth;
        worldNormal = gBufferA_WYZX.yzw * 2.0f - 1.0f;
        materialParams_squared = float3(0.0f, 0.0f, 0.0f);
        gBufferD_Z_copy = 0.0f; // 保持状态一致
        shadingModel_flag_copies = float2(0.0f, 0.0f); // 保持状态一致
    }
    float worldNormal_lenSq = dot(worldNormal, worldNormal);
    float invLen_worldNormal = rsqrt(worldNormal_lenSq);
    float3 normalizedWorldNormal = worldNormal * invLen_worldNormal;
    bool isShadingModel_5_or_13 = (shadingModelFlags.x == 5) || (shadingModelFlags.x == 13);
    bool useDitherPattern = (cb1[162].y > 0.0f) && (cb2[220].z > 0.0f);
    bool isAlbedoForced = (cb1[162].y != 0);
    float3 albedoOrWhite = isAlbedoForced ? float3(1.0f, 1.0f, 1.0f) : albedo;
    float checkerboardPattern_float = checkerboardPattern ? 1.0f : 0.0f;
    float3 albedoOrCheckerboard = useDitherPattern ? float3(checkerboardPattern_float, checkerboardPattern_float, checkerboardPattern_float) : albedoOrWhite;
    float3 finalAlbedo = isShadingModel_5_or_13 ? albedoOrCheckerboard : albedo;
    float eyeAdaptation = tex2Dlod(_IN9, float4(0, 0, 0, 0)).x;
    float2 worldPos_proj = uvAndNDC.zw * finalLinearEyeDepth;
    float3 viewSpacePos = cb1[49].xyz * worldPos_proj.y;
    viewSpacePos = worldPos_proj.x * cb1[48].xyz + viewSpacePos;
    viewSpacePos = finalLinearEyeDepth * cb1[50].xyz + viewSpacePos;
    float3 worldPosition = cb1[51].xyz + viewSpacePos;
    float2 shadowMask_TermAndStrength = tex2Dlod(_IN5, float4(uvAndNDC.xy, 0, 0)).xz;
    float2 shadowMask_squared = shadowMask_TermAndStrength * shadowMask_TermAndStrength;
    float shadowFactor = shadowMask_squared.x * shadowMask_squared.y;
    float finalShadowFactor = cb1[253].y * shadowFactor;

    float3 finalLighting;
    float3 specular_base_color;
    if (cb1[255].x != 0) {
        float3 ssrAccumulator = float3(0.0f, 0.0f, 0.0f);
        float ssrRadius = 0.0f;
        float ssrStep = 0.0f;
        float ssrTotalWeight = 0.0f;
        int outerLoopCount = 0;
        while (true) {
            bool endOuterLoop = (outerLoopCount >= 3);
            if (endOuterLoop) break;
            ssrStep += 0.000833333295f;
            float3 innerLoopAccumulator = ssrAccumulator;
            float ssrAngle = shadingModel_flag_copies.y; // r5.w
            float innerLoopTotalWeight = ssrTotalWeight;
            int innerLoopCount = 0;
            while (true) {
                bool endInnerLoop = (innerLoopCount >= 3);
                if (endInnerLoop) break;
                ssrAngle += 1.0f;
                float currentAngleRad = 2.09439516f * ssrAngle;
                float sinAngle, cosAngle;
                sincos(currentAngleRad, sinAngle, cosAngle);
                float ssrSampleU = cosAngle * ssrStep + uvAndNDC.x;
                float ssrSampleV = sinAngle * ssrStep + uvAndNDC.y;
                float3 blackSample = tex2D(_IN7, float2(ssrSampleU, ssrSampleV)).xyz;
                innerLoopAccumulator += blackSample * ssrStep;
                innerLoopTotalWeight += ssrStep;
                innerLoopCount++;
            }
            ssrAccumulator = innerLoopAccumulator;
            ssrTotalWeight = innerLoopTotalWeight;
            shadingModel_flag_copies.y = 0.620000005f + ssrAngle;
            outerLoopCount++;
        }
        float3 ssrResult = ssrAccumulator / ssrTotalWeight;
        bool3 colorRangeCheck1 = (float3(0.644999981f, 0.312000006f, 0.978999972f) < gBufferA_WYZX.xxx);
        bool3 colorRangeCheck2 = (gBufferA_WYZX.xxx < float3(0.685000002f, 0.351999998f, 1.02100003f));
        bool3 inColorRange = colorRangeCheck1 && colorRangeCheck2;
        float colorSelect = inColorRange.z ? 1.0f : 0.0f;
        colorSelect = inColorRange.y ? 0.0f : colorSelect;
        colorSelect = inColorRange.x ? 1.0f : colorSelect;
        int colorRange_anyYorZ = (int)inColorRange.y | (int)inColorRange.z;
        int colorRange_any_asFloat = colorRange_anyYorZ & 0x3f800000;
        float finalColorSelect = inColorRange.x ? 0.0f : (float)colorRange_any_asFloat;
        uint gBufferD_X_encoded = (uint)round(gBufferD_YXZ.x * 255.0f);
        uint4 materialFlags = (uint4)gBufferD_X_encoded & uint4(15, 240, 240, 15);
        float smoothstep_in1 = saturate(gBufferA_WYZX.w * 2.0f);
        float smoothstep_poly1 = smoothstep_in1 * smoothstep_in1 * (3.0f - 2.0f * smoothstep_in1);
        float smoothstep_in2 = saturate((gBufferA_WYZX.w - 0.5f) * 2.0f);
        float smoothstep_poly2 = smoothstep_in2 * smoothstep_in2 * (3.0f - 2.0f * smoothstep_in2);
        float3 colorDiff = cb1[262].xyz - cb1[261].xyz;
        float colorDiff_luma = dot(abs(colorDiff), float3(0.300000012f, 0.589999974f, 0.109999999f));
        float smoothstep_in3 = min(1.0f, 10.0f * colorDiff_luma);
        float smoothstep_poly3 = smoothstep_in3 * smoothstep_in3 * (3.0f - 2.0f * smoothstep_in3);
        float combined_smoothstep_1 = smoothstep_poly3 * smoothstep_poly2;
        float range_blend_min = cb1[265].x;
        float range_blend_max = cb1[265].y;
        float range_blend_inv_dist = 1.0f / (range_blend_max - range_blend_min);
        float blend_alpha_unclamped = (finalShadowFactor - range_blend_min) * range_blend_inv_dist;
        float blend_alpha = saturate(blend_alpha_unclamped);
        float blend_poly = blend_alpha * blend_alpha * (3.0f - 2.0f * blend_alpha);
        float combined_smoothstep_2 = blend_poly * combined_smoothstep_1;
        float blended_shadow_val1 = finalShadowFactor - combined_smoothstep_2;
        float blended_shadow_final = cb1[265].z * blended_shadow_val1 + combined_smoothstep_2;
        float post_blend_shadow = blended_shadow_final - range_blend_min;
        float final_blend_alpha_unclamped = post_blend_shadow * range_blend_inv_dist;
        float final_blend_alpha = saturate(final_blend_alpha_unclamped);
        float final_blend_poly = final_blend_alpha * final_blend_alpha * (3.0f - 2.0f * final_blend_alpha);
        float final_combined_smoothstep = final_blend_poly * combined_smoothstep_1;
        float lerp_factor_1 = smoothstep_poly2 * smoothstep_poly3 - final_combined_smoothstep;
        float lerped_val_1 = cb1[265].z * lerp_factor_1 + final_combined_smoothstep;
        float lerp_factor_2 = checkerboardPattern - blended_shadow_final;
        float lerped_val_2 = shadingModel_flag_copies.x * lerp_factor_2 + blended_shadow_final;
        float lerp_factor_3 = checkerboardPattern * lerped_val_1 - lerped_val_1;
        float lerped_val_3 = shadingModel_flag_copies.x * lerp_factor_3 + lerped_val_1;
        bool is_ssr_greater = ssrResult.y >= ssrResult.z;
        float hsv_selector = is_ssr_greater ? 1.0f : 0.0f;
        float4 hsv_base = is_ssr_greater ? float4(ssrResult.z, ssrResult.y, -1.0f, 0.666666687f) : float4(ssrResult.y, ssrResult.z, 1.0f, -1.0f);
        float4 hsv_intermediate = float4(hsv_base.w, 0.0f, 0.0f, 0.0f);
        hsv_intermediate = hsv_selector * float4(0.0f, hsv_base.y - hsv_base.x, 1.0f, -1.0f) + hsv_intermediate;
        bool is_ssr_x_greater = ssrResult.x >= hsv_intermediate.x;
        float hsv_selector_2 = is_ssr_x_greater ? 1.0f : 0.0f;
        float4 hsv_base_2 = float4(hsv_intermediate.x, hsv_intermediate.y, hsv_intermediate.w, ssrResult.x);
        float4 hsv_intermediate_2 = float4(hsv_base_2.w, hsv_base_2.y, hsv_base_2.x, 0.0f);
        hsv_intermediate_2 = hsv_intermediate_2 - hsv_base_2;
        float4 hsv_final_unselected = hsv_intermediate_2 * hsv_selector_2 + hsv_base_2;
        float hsv_v = hsv_final_unselected.x;
        float hsv_s = (hsv_v - min(hsv_final_unselected.w, hsv_final_unselected.y)) / (hsv_v + 0.00100000005f);
        float hsv_h_div = (hsv_final_unselected.w - hsv_final_unselected.y) * 6.0f + 0.00100000005f;
        float hsv_h = hsv_final_unselected.z + (hsv_final_unselected.w - hsv_final_unselected.y) / hsv_h_div;
        float hsv_s_div = hsv_v + 0.00100000005f;
        float hsv_s_mod = hsv_s / hsv_s_div;
        float luma_factor = 0.300000012f * hsv_v + 1.0f;
        float4 materialFlagRemap = materialFlags * float4(0.0400000028f, 0.0027450982f, 0.00392156886f, 0.0666666701f) + float4(0.400000006f, 0.400000006f, 1.0f, 0.5f);
        bool isMatFlagHigh = (materialFlags.z >= 2.54999971f);
        float materialFlagRemap_blend = isMatFlagHigh ? (materialFlagRemap.y - materialFlagRemap.x) : 0.0f;
        float finalMaterialRemap_x = materialFlagRemap_blend + materialFlagRemap.x;
        float hsv_s_final = finalMaterialRemap_x * hsv_s_mod;
        hsv_s_final = min(0.349999994f, hsv_s_final);
        float hsv_s_clamped = max(0.0f, hsv_s_final);
        float3 hsv_to_rgb_base = abs(hsv_h) + float3(1.0f, 0.666666687f, 0.333333343f);
        hsv_to_rgb_base = frac(hsv_to_rgb_base);
        hsv_to_rgb_base = hsv_to_rgb_base * 6.0f - 3.0f;
        hsv_to_rgb_base = saturate(abs(hsv_to_rgb_base) - 1.0f);
        float3 hsv_to_rgb_intermediate = hsv_to_rgb_base * -1.0f + 1.0f;
        float hsv_s_factor = 1.0f + hsv_s_final;
        float3 rgb_from_hsv_1 = hsv_to_rgb_intermediate * hsv_s_factor;
        float3 rgb_from_hsv_2 = rgb_from_hsv_1 - 1.0f;
        rgb_from_hsv_2 = rgb_from_hsv_2 * 0.600000024f + 1.0f;
        float3 rgb_from_hsv_3 = -hsv_to_rgb_intermediate * hsv_s_factor + rgb_from_hsv_2;
        float3 rgb_from_hsv_lerped = gBufferA_WYZX.xxx * rgb_from_hsv_3 + rgb_from_hsv_1;
        float3 desaturated_color = (rgb_from_hsv_lerped - albedo) * 0.850000024f + albedo;
        float3 color_blend_factor = materialFlagRemap.zzz * desaturated_color - rgb_from_hsv_lerped;
        float3 color_blend_1 = ssrResult * color_blend_factor + rgb_from_hsv_lerped;
        float3 color_blend_2 = (color_blend_1 - 1.0f) * materialFlagRemap.www + 1.0f;
        float3 specColor_base = cb1[261].xyz * 0.200000003f;
        float3 specColor_range = cb1[262].xyz * 0.5f - specColor_base;
        float3 specColor_lerped1 = lerped_val_3 * specColor_range + specColor_base;
        float3 specColor_final = cb1[260].xxx * specColor_lerped1 * albedo;
        float3 specColor_term1 = specColor_final * materialParams_squared.xyz;
        float3 specColor_direct = cb1[261].xyz * albedo;
        float specular_blend_factor = gBufferD_YXZ.x * 0.300000012f + 0.699999988f;
        specular_base_color = specColor_direct * specular_blend_factor;
        float3 specular_mix_1 = specular_base_color + specColor_term1;
        float3 specular_range = cb1[262].xyz * albedo - specular_base_color;
        float3 specular_lerped = specular_range * 0.400000006f + specular_base_color;
        float3 specular_layer1 = specular_base_color * color_blend_2;
        float3 specular_layer2_range = specular_lerped * color_blend_2 - specular_layer1;
        float3 specular_layer2 = lerped_val_2 * specular_layer2_range + specular_layer1;
        float3 final_specular = specColor_final * materialParams_squared.xyz + specular_layer2;
        float3 specular_mix_2 = specular_mix_1 * color_blend_2;
        float3 spec_lobe_color = cb1[262].xyz * final_blend_poly;
        float3 spec_lobe_range = spec_lobe_color * color_blend_2 - specular_mix_2;
        float3 spec_lobe_lerped = lerped_val_2 * spec_lobe_range + specular_mix_2;
        float ao_raw = tex2Dlod(_IN8, float4(uvAndNDC.xy, 0, 0)).x;
        float ao_factor = (float)isClothHairOrEye_flag * (ao_raw - 1.0f) + 1.0f;
        float3 final_specular_desaturated = (spec_lobe_lerped - final_specular) * lerped_val_3 + final_specular;
        float3 ambient_occlusion_mask = 1.0f - ssrResult;
        float3 final_color_occluded = ao_factor * ambient_occlusion_mask + ssrResult;
        finalLighting = final_specular_desaturated * final_color_occluded;
    } else {
        float smoothstep_in1_alt = saturate(gBufferA_WYZX.w * 2.0f);
        float smoothstep_poly1_alt = smoothstep_in1_alt * smoothstep_in1_alt * (3.0f - 2.0f * smoothstep_in1_alt);
        float smoothstep_in2_alt = saturate((gBufferA_WYZX.w - 0.5f) * 2.0f);
        float smoothstep_poly2_alt = smoothstep_in2_alt * smoothstep_in2_alt * (3.0f - 2.0f * smoothstep_in2_alt);
        float3 colorDiff_alt = cb1[262].xyz - cb1[261].xyz;
        float colorDiff_luma_alt = dot(abs(colorDiff_alt), float3(0.300000012f, 0.589999974f, 0.109999999f));
        float smoothstep_in3_alt = min(1.0f, 10.0f * colorDiff_luma_alt);
        float smoothstep_poly3_alt = smoothstep_in3_alt * smoothstep_in3_alt * (3.0f - 2.0f * smoothstep_in3_alt);
        float combined_smoothstep_1_alt = smoothstep_poly3_alt * smoothstep_poly2_alt;
        float range_blend_min_alt = cb1[265].x;
        float range_blend_max_alt = cb1[265].y;
        float range_blend_inv_dist_alt = 1.0f / (range_blend_max_alt - range_blend_min_alt);
        float blend_alpha_unclamped_alt = (finalShadowFactor - range_blend_min_alt) * range_blend_inv_dist_alt;
        float blend_alpha_alt = saturate(blend_alpha_unclamped_alt);
        float blend_poly_alt = blend_alpha_alt * blend_alpha_alt * (3.0f - 2.0f * blend_alpha_alt);
        float combined_smoothstep_2_alt = blend_poly_alt * combined_smoothstep_1_alt;
        float blended_shadow_val1_alt = finalShadowFactor - combined_smoothstep_2_alt;
        float blended_shadow_final_alt = cb1[265].z * blended_shadow_val1_alt + combined_smoothstep_2_alt;
        float post_blend_shadow_alt = blended_shadow_final_alt - range_blend_min_alt;
        float final_blend_alpha_unclamped_alt = post_blend_shadow_alt * range_blend_inv_dist_alt;
        float final_blend_alpha_alt = saturate(final_blend_alpha_unclamped_alt);
        float final_blend_poly_alt = final_blend_alpha_alt * final_blend_alpha_alt * (3.0f - 2.0f * final_blend_alpha_alt);
        float final_combined_smoothstep_alt = final_blend_poly_alt * combined_smoothstep_1_alt;
        float lerp_factor_1_alt = smoothstep_poly2_alt * smoothstep_poly3_alt - final_combined_smoothstep_alt;
        float lerped_val_1_alt = cb1[265].z * lerp_factor_1_alt + final_combined_smoothstep_alt;
        float sheen_factor = blended_shadow_final_alt * gBufferD_YXZ.y;
        float sheen_intensity = 10.0f * sheen_factor;
        float blended_shadow_offset = blended_shadow_final_alt - 1.0f;
        float lerped_val_2_base = cb1[260].y * blended_shadow_offset + 1.0f;
        float lerp_factor_2_alt = checkerboardPattern * lerped_val_1_alt - lerped_val_2_base;
        float lerped_val_2_alt = gBufferD_YXZ.x * lerp_factor_2_alt + lerped_val_2_base;
        float lerp_factor_3_alt = checkerboardPattern * lerped_val_1_alt - lerped_val_1_alt;
        float lerped_val_3_alt = gBufferD_YXZ.x * lerp_factor_3_alt + lerped_val_1_alt;
        float3 specColor_base_alt = cb1[261].xyz * 0.200000003f;
        float3 specColor_range_alt = cb1[262].xyz * 0.5f - specColor_base_alt;
        float3 specColor_lerped1_alt = lerped_val_2_alt * specColor_range_alt + specColor_base_alt;
        float3 specColor_final_alt = cb1[260].xxx * specColor_lerped1_alt * albedo;
        float3 specColor_term1_alt = specColor_final_alt * materialParams_squared.xyz;
        float3 specColor_direct_alt = cb1[261].xyz * albedo;
        float specular_blend_factor_alt = smoothstep_poly1_alt * 0.300000012f + 0.699999988f;
        float3 specular_base_color_alt = specColor_direct_alt * specular_blend_factor_alt;
        float3 specular_mix_1_alt = specular_base_color_alt + specColor_term1_alt;
        float3 specular_mix_2_alt = sheen_intensity * specColor_term1_alt + specular_mix_1_alt;
        float3 specular_range_alt = albedo * cb1[262].xyz - specular_base_color_alt;
        float3 specular_lerped_alt = specular_range_alt * lerped_val_3_alt;
        float3 specular_lerped_2_alt = specular_lerped_alt * 0.400000006f + specular_base_color_alt;
        float3 final_specular_alt = specColor_final_alt * materialParams_squared.xyz + specular_lerped_2_alt;
        float3 spec_lobe_range_alt = albedo * cb1[262].xyz - specular_mix_2_alt;
        float3 spec_lobe_lerped_alt = lerped_val_3_alt * spec_lobe_range_alt + specular_mix_2_alt;
        float3 final_specular_desaturated_alt = (spec_lobe_lerped_alt - final_specular_alt) * lerped_val_2_alt + final_specular_alt;
        finalLighting = final_specular_desaturated_alt;
    }
    float smoothstep_in_final = saturate((gBufferA_WYZX.w - 0.400000006f) * 10.000001f);
    float smoothstep_poly_final = smoothstep_in_final * smoothstep_in_final * (3.0f - 2.0f * smoothstep_in_final);
    float3 specColor_base_final = gBufferD_YXZ.x * finalLighting * 0.5f + cb1[261].xyz;
    float3 specColor_final_lerped = specColor_base_final * albedo;
    float3 specColor_direct_final = cb1[261].xyz * albedo;
    float3 final_spec_lerp1 = cb1[255].xxx ? specColor_final_lerped : specColor_direct_final;
    float3 final_spec_lerp2 = checkerboardPattern ? final_spec_lerp1 : specular_base_color;
    float3 final_spec_lerp3 = checkerboardPattern ? final_spec_lerp1 : finalLighting;
    float2 final_spec_remap = checkerboardPattern ? float2(0.0f, 0.0f) : float2(gBufferD_YXZ.x, smoothstep_poly_final);
    float3 sky_specular_reflection = cb1[264].xyz + cb1[264].xyz;
    float3 final_sky_specular = final_spec_remap.x * sky_specular_reflection - cb1[264].xyz;
    float3 totalLightContribution = float3(0.0f, 0.0f, 0.0f);
    float occlusionFactor = 1.0f;
    uint lightIndex = 0;
    while (true) {
        bool endLightLoop = (lightIndex >= asuint(cb2[128].x));
        if (endLightLoop) break;
        uint lightDataOffset = (lightIndex << 3);
        uint lightMaskCheckOffset = lightDataOffset | 7;
        uint lightTypeMask = (uint)cb2[lightMaskCheckOffset + 0].w << 5;
        uint lightType = (uint)shadingModelFlags.y & lightTypeMask;
        if (lightType == 0) {
            lightIndex = lightIndex + 1;
            continue;
        }
        float3 lightVector = cb2[lightDataOffset + 0].xyz - worldPosition;
        float lightRadiusSq = cb2[lightDataOffset + 0].w * cb2[lightDataOffset + 0].w;
        float distToLightSq = dot(lightVector, lightVector);
        bool inLightRange = (1.0f >= (distToLightSq * lightRadiusSq));
        if (inLightRange) {
            uint lightDataOffset1 = lightDataOffset | 1;
            uint lightDataOffset2 = lightDataOffset | 2;
            uint lightDataOffset3 = lightDataOffset | 3;
            uint lightDataOffset4 = lightDataOffset | 4;
            uint lightDataOffset5 = lightDataOffset | 5;
            uint lightDataOffset6 = lightDataOffset | 6;
            float lightFalloff_unclamped = saturate(distToLightSq * lightRadiusSq * 2.5f - 1.5f);
            float lightFalloff_sq = lightFalloff_unclamped * lightFalloff_unclamped;
            float lightFalloff = 1.0f - lightFalloff_sq * (3.0f - 2.0f * lightFalloff_unclamped);
            float invDistToLight = rsqrt(distToLightSq);
            float3 L = lightVector * invDistToLight;
            float NdotL = dot(normalizedWorldNormal, L);
            float NdotL_remap = NdotL * 0.5f + 1.0f - (cb2[lightDataOffset5 + 0].w * 0.939999998f);
            float invLightSpread = 1.0f / (cb2[lightDataOffset5 + 0].w * 0.0600000024f);
            float lightSpreadFactor = saturate(invLightSpread * NdotL_remap);
            float lightSpread_poly = lightSpreadFactor * lightSpreadFactor * (3.0f - 2.0f * lightSpreadFactor);
            float finalLightSpread = min(1.0f, lightSpread_poly);
            float3 lightColor_base = cb2[lightDataOffset6 + 0].xyz * final_spec_lerp2;
            float3 lightColor_spec_range = albedo * cb2[lightDataOffset5 + 0].xyz - lightColor_base;
            float3 lightColor_spec = finalLightSpread * lightColor_spec_range + lightColor_base;
            float3 lightColor_final = (float)checkerboardPattern * lightColor_spec;
            float attenuation_factor = cb2[lightDataOffset4 + 0].x * (dot(lightVector, lightVector)) + cb2[lightDataOffset4 + 0].y;
            float inv_attenuation = 1.0f / (attenuation_factor + 9.99999975e-005f);
            float lightAttenuation = (inv_attenuation - 1.0f) * cb2[lightDataOffset4 + 0].z;
            lightAttenuation = min(1.0f, lightAttenuation * lightAttenuation);
            uint lightProfileMask = (uint)cb2[lightDataOffset1 + 0].w >> 16;
            bool useProfiledLight = (lightProfileMask == 2);
            float VdotL = dot(L, cb2[lightDataOffset1 + 0].xyz);
            float VdotL_remap = saturate((VdotL - cb2[lightDataOffset2 + 0].x) * cb2[lightDataOffset2 + 0].y);
            float VdotL_poly = VdotL_remap * VdotL_remap * VdotL_remap * VdotL_remap;
            float profiledLightAttenuation = VdotL_poly * lightAttenuation;
            lightAttenuation = useProfiledLight ? profiledLightAttenuation : lightAttenuation;
            float NdotV_like = dot(final_sky_specular, L);
            float fresnel_factor = saturate(NdotV_like * 0.5f + 0.5f);
            float fresnel_lerp = smoothstep_poly_final * fresnel_factor - final_spec_remap.y;
            float final_fresnel = cb2[lightDataOffset4 + 0].w * fresnel_lerp + final_spec_remap.y;
            float3 reflection_base = cb2[lightDataOffset3 + 0].www * final_spec_lerp2;
            float3 reflection_range = albedo - final_spec_lerp2 * cb2[lightDataOffset3 + 0].www;
            float3 reflection_color = final_fresnel * reflection_range + reflection_base;
            reflection_color = cb2[lightDataOffset3 + 0].xyz * reflection_color;
            float lightLuma = cb2[lightDataOffset3 + 0].x + cb2[lightDataOffset3 + 0].y + cb2[lightDataOffset3 + 0].z + (float)checkerboardPattern;
            float lightLuma_factor = saturate(10.0f * lightLuma);
            float shadowStrength = (float)checkerboardPattern * lightLuma_factor;
            float3 lightContribution = lightColor_final * lightAttenuation;
            lightContribution = reflection_color * lightAttenuation + lightContribution;
            float lightFalloff_remaining = lightFalloff - lightAttenuation;
            float attenuatedFalloff = cb2[lightDataOffset6 + 0].w * lightFalloff_remaining + lightAttenuation;
            totalLightContribution += lightContribution * occlusionFactor;
            float newOcclusion = 1.0f - attenuatedFalloff * shadowStrength;
            occlusionFactor = newOcclusion * occlusionFactor;
        }
        lightIndex = lightIndex + 1;
    }
    float3 finalColor = occlusionFactor * final_spec_lerp3 + totalLightContribution;
    bool isClothModel = (shadingModelFlags.x == 13);
    float contactShadow_final;
    if (!isClothModel) {
        bool isSkinModel = (shadingModelFlags.x == 1);
        float roughness_remap = isSkinModel ? gBufferD_YXZ.z : gBufferD_YXZ.y;
        float3 viewVector = cb1[67].xyz - worldPosition;
        float invLen_viewVector = rsqrt(dot(viewVector, viewVector));
        float3 V = viewVector * invLen_viewVector;
        float roughness_remap_clamped = saturate(roughness_remap - 0.100000001f);
        float roughness_scaled = saturate(10.0f * roughness_remap) * 0.800000012f;
        float contactShadowLength = roughness_remap_clamped * 2000.0f + 50.0f;
        float contactShadowInput = roughness_remap_clamped + roughness_remap_clamped;
        roughness_scaled = cb0[0].x * roughness_scaled + contactShadowInput;
        float3 lightDir_Primary = cb1[20].xyz * normalizedWorldNormal.x + cb1[21].xyz * normalizedWorldNormal.y + cb1[22].xyz * normalizedWorldNormal.z;
        bool useSkylight = (asint(cb0[0].w) > 0.5f);
        V = useSkylight ? float3(0.0f, 0.0f, 0.0f) : V;
        float2 halfVectorDir = useSkylight ? cb0[0].yz : cb1[264].xy;
        float halfVectorDirZ = useSkylight ? 0.5f : cb1[264].z;
        float3 H = float3(halfVectorDir, halfVectorDirZ);
        lightDir_Primary = useSkylight ? specColor_final_lerped : lightDir_Primary;
        float LdotH = dot(H, lightDir_Primary);
        float LdotH_remap = saturate(5.0f * (LdotH + 0.200000003f));
        float LdotH_poly = LdotH_remap * LdotH_remap * (3.0f - 2.0f * LdotH_remap);
        float3 H_plus_V = H + V;
        float invLen_H_plus_V = rsqrt(dot(H_plus_V, H_plus_V));
        float3 L_refl = H_plus_V * invLen_H_plus_V;
        float NdotL_refl = saturate(dot(lightDir_Primary, L_refl));
        float specular_D = NdotL_refl * NdotL_refl * (1.0f - 0.800000012f) + 1.0f;
        float specular_D_invSq = 3.14159274f * (specular_D * specular_D);
        float specular_D_final = 0.200000003f / specular_D_invSq * checkerboardPattern;
        float VdotH = dot(H, V);
        float fresnel_remap = saturate((1.0f - VdotH) * 2.0f);
        float fresnel_poly = fresnel_remap * fresnel_remap * (3.0f - 2.0f * fresnel_remap) + 1.0f;
        float NdotV_final = saturate(dot(V, normalizedWorldNormal));
        float fresnel_G_factor = 1.0f - max(0.0f, NdotV_final);
        float scattering_angle = min(1.74532926f, max(0.0f, cb1[133].x));
        float2 scattering_remap = float2(1.5f, 0.572957814f) * float2(fresnel_G_factor, scattering_angle);
        float depth_remap_max = max(0.0f, linearEyeDepth);
        float2 depth_remap = min(float2(3000.0f, 50.0f), depth_remap_max);
        depth_remap = (float2(3000.0f, 50.0f) - depth_remap) * float2(0.00033333333f, 0.0199999996f);
        float depth_poly = depth_remap.x * depth_remap.x;
        depth_poly = depth_poly * depth_poly * depth_poly + depth_remap.y;
        float scattering_F = (scattering_remap.y * (depth_poly - 1.0f)) + 1.0f;
        float scattering_F_lerped = roughness_remap_clamped * (1.0f - scattering_F) + scattering_F;
        float scattering_final = (LdotH + 1.0f) * 0.25f + 0.5f;
        float spec_lobe = scattering_final * scattering_remap.x * scattering_F_lerped * fresnel_poly * 0.00999999978f;
        float2 spec_remap = (gBufferB.xy + 9.99999975e-005f) * rsqrt(dot(gBufferB.xy, gBufferB.xy));
        spec_remap *= roughness_scaled;
        float spec_final = spec_remap.y * spec_lobe;
        float2 spec_offset = float2(-0.5f, 0.0f) * float2(spec_lobe, spec_remap.x);
        float fresnel_V_remap = 0.400000006f * (1.0f - VdotH);
        float spec_D_remap = LdotH_poly * 0.800000012f + 0.200000003f;
        float specular_final = fresnel_V_remap * spec_D_remap + (1.5f * specular_D_final * LdotH_poly);
        specular_final = ((checkerboardPattern * 0.5f) + 0.5f) * specular_final;
        float2 contactShadow_uv_offset = (uvAndNDC.xy * cb1[138].xy - cb1[134].xy) * cb1[135].zw + spec_offset;
        float2 contactShadow_uv = (contactShadow_uv_offset * cb1[135].xy + cb1[134].xy) * cb1[138].zw;
        float contactShadow_sceneDepth = tex2D(_IN6, contactShadow_uv).x;
        float contactShadow_linearDepth_part1 = contactShadow_sceneDepth * cb1[65].x + cb1[65].y;
        float contactShadow_linearDepth_part2 = contactShadow_sceneDepth * cb1[65].z - cb1[65].w;
        float inv_contactShadow_linearDepth_part2 = 1.0f / contactShadow_linearDepth_part2;
        float contactShadow_linearDepth = contactShadow_linearDepth_part1 + inv_contactShadow_linearDepth_part2;
        float contactShadow_depthDelta = max(9.99999975e-005f, contactShadow_linearDepth - linearEyeDepth);
        float contactShadow_factor_unclamped = (contactShadow_depthDelta - roughness_remap_clamped * 1000.0f) / contactShadowLength;
        float contactShadow_factor = saturate(contactShadow_factor_unclamped);
        float contactShadow_poly = contactShadow_factor * contactShadow_factor * (3.0f - 2.0f * contactShadow_factor);
        contactShadow_final = min(1.0f, contactShadow_poly);
        float ambient_luma = dot(cb1[263].xyz, float3(0.300000012f, 0.589999974f, 0.109999999f));
        float3 ambient_desaturated = (cb1[263].xyz - ambient_luma) * 0.75f + ambient_luma;
        float3 ambient_color = checkerboardPattern * (cb1[263].xyz - ambient_desaturated) + ambient_desaturated;
        ambient_color = roughness_scaled * ambient_color * 0.100000001f;
        float3 ambient_base = (albedo + 1.0f) * ambient_color;
        float3 albedo_remap = saturate((albedo * 1.20000005f) - 1.0f);
        float3 albedo_poly = albedo_remap * albedo_remap * (3.0f - 2.0f * albedo_remap);
        float3 ambient_final_layer = albedo_poly * 14.0f + 1.0f;
        float3 ambient_final_color = ambient_final_layer * ambient_color;
        float3 ambient_result = cb1[260].zzz * (ambient_final_color * albedo - ambient_base) + ambient_base;
        ambient_result = contactShadow_final * ambient_result;
        float fog_depth = max(0.0f, linearEyeDepth - 10000.0f);
        fog_depth = min(5000.0f, fog_depth);
        float fog_factor = (5000.0f - fog_depth) * 0.000199999995f;
        ambient_result = fog_factor * ambient_result;
        finalColor = cb0[1].xyz * ambient_result;
    } else {
        finalColor = float3(0.0f, 0.0f, 0.0f);
    }
    bool useHairModel = (isClothHairEye_flags.z != 0.0f);
    float3 hair_lighting_range = cb1[263].xyz * (finalColor * materialParams_squared.xyz) * 0.5f - finalColor;
    float3 hair_lighting_lerped = contactShadow_final * hair_lighting_range + finalColor;
    finalColor = finalColor + finalLighting;
    finalColor = useHairModel ? hair_lighting_lerped : finalColor;
    float3 final_color_composited = checkerboardPattern ? finalColor : (final_spec_lerp3 / eyeAdaptation);
    float3 clamped_output = min(float3(0.0f, 0.0f, 0.0f), -final_color_composited);
    color.xyz = -clamped_output;
    return color;
}
B:
float4 frag (VertexToFragment fragmentInput) : SV_Target
{
    float4 v0 = fragmentInput.uv; 

    float4 color = 0;
    
    float4 r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15,r16;
    uint4 bitmask, uiDest;
    float4 fDest;

    r0.xyzw = tex2Dlod(_IN1, float4(v0.xy, 0, 0)).wxyz;
    r1.xyzw = tex2Dlod(_IN2, float4(v0.xy, 0, 0)).xyzw;
    r2.xyz = tex2Dlod(_IN3, float4(v0.xy, 0, 0)).xyz;
    r3.xyz = tex2Dlod(_IN4, float4(v0.xy, 0, 0)).yxz;
    r2.w = tex2Dlod(_IN0, float4(v0.xy, 0, 0)).x;
    r3.w = r2.w * cb1[65].x + cb1[65].y;
    r2.w = r2.w * cb1[65].z + -cb1[65].w;
    r2.w = 1 / r2.w;
    r2.w = r3.w + r2.w;
    r4.xy = cb1[138].xy * v0.xy;
    r4.xy = (uint2)r4.xy;
    r3.w = (uint)cb1[158].x;
    r4.x = (int)r4.y + (int)r4.x;
    r3.w = (int)r3.w + (int)r4.x;
    r3.w = (int)r3.w & 1;
    r1.w = 255 * r1.w;
    r1.w = round(r1.w);
    r1.w = (uint)r1.w;
    r4.xy = (int2)r1.ww & int2(15,-16);
    r1.w = ((int)r4.x != 12) ? 1.0 : 0.0;
    r5.xyz = ((int3)r4.xxx == int3(13,14,15)) ? 1.0 : 0.0;
    r4.z = (int)r5.z | (int)r5.y;
    r4.z = (int)r4.z | (int)r5.x;
    r1.w = r1.w ? r4.z : -1;
    if (r1.w != 0) {
        r4.x = r5.x ? 13 : 12;
        r5.xz = r5.yz ? float2(1,1) : 0;
        r4.zw = r0.yz * float2(2,2) + float2(-1,-1);
        r1.w = dot(float2(1,1), abs(r4.zw));
        r6.z = 1 + -r1.w;
        r1.w = max(0, -r6.z);
        r7.xy = (r4.zw >= float2(0,0)) ? 1.0 : 0.0;
        r7.xy = r7.xy ? float2(0.5,0.5) : float2(-0.5,-0.5);
        r7.xy = r7.xy * r1.ww;
        r6.xy = r7.xy * float2(-2,-2) + r4.zw;
        r1.w = dot(r6.xyz, r6.xyz);
        r1.w = rsqrt(r1.w);
        r6.xyz = r6.xyz * r1.www;
        r7.xyz = r1.xyz * r1.xyz;
        r5.y = r3.z;
    } else {
        r1.w = ((int)r4.x == 10) ? 1.0 : 0.0;
        r1.xyz = saturate(r1.xyz);
        r1.xyz = float3(16777215,65535,255) * r1.xyz;
        r1.xyz = round(r1.xyz);
        r1.xyz = (uint3)r1.xyz;
        bitmask.y = ((~(-1 << 8)) << 0) & 0xffffffff;  r1.y = (((uint)r1.z << 0) & bitmask.y) | ((uint)r1.y & ~bitmask.y);
        bitmask.x = ((~(-1 << 16)) << 0) & 0xffffffff;  r1.x = (((uint)r1.y << 0) & bitmask.x) | ((uint)r1.x & ~bitmask.x);
        r1.x = (uint)r1.x;
        r1.x = 5.96046519e-008 * r1.x;
        r1.y = r1.x * cb1[65].x + cb1[65].y;
        r1.x = r1.x * cb1[65].z + -cb1[65].w;
        r1.x = 1 / r1.x;
        r1.x = r1.y + r1.x;
        r2.w = r1.w ? r1.x : r2.w;
        r6.xyz = r0.yzw * float3(2,2,2) + float3(-1,-1,-1);
        r7.xyz = float3(0,0,0);
        r5.xyz = float3(0,0,0);
        r0.xw = float2(0,0);
        r3.xy = float2(0,0);
    }
    r0.y = dot(r6.xyz, r6.xyz);
    r0.y = rsqrt(r0.y);
    r1.xyz = r6.xyz * r0.yyy;
    r0.yz = ((int2)r4.xx == int2(5,13)) ? 1.0 : 0.0;
    r1.w = (0 < cb1[162].y) ? 1.0 : 0.0;
    r4.z = (0 < cb1[220].z) ? 1.0 : 0.0;
    r1.w = r1.w ? r4.z : 0;
    r4.z = (0 != cb1[162].y) ? 1.0 : 0.0;
    r6.xyz = r4.zzz ? float3(1,1,1) : r2.xyz;
    r3.w = r3.w ? 1 : 0;
    r6.xyz = r1.www ? r3.www : r6.xyz;
    r2.xyz = r0.yyy ? r6.xyz : r2.xyz;
    r0.y = tex2Dlod(_IN9, float4(0, 0, 0, 0)).x;
    r4.zw = v0.zw * r2.ww; // 此处的v0.zw根据前面的定义将为0
    r6.xyz = cb1[49].xyz * r4.www;
    r6.xyz = r4.zzz * cb1[48].xyz + r6.xyz;
    r6.xyz = r2.www * cb1[50].xyz + r6.xyz;
    r6.xyz = cb1[51].xyz + r6.xyz;
    r4.zw = tex2Dlod(_IN5, float4(v0.xy, 0, 0)).xz;
    r4.zw = r4.zw * r4.zw;
    r1.w = r4.z * r4.w;
    r3.w = cb1[253].y * r1.w;
    if (cb1[255].x != 0) {
        r8.xyz = float3(0,0,0);
        r4.zw = float2(0,0);
        r5.w = 0;
        r6.w = 0;
        while (true) {
        r7.w = ((int)r4.z >= 3) ? 1.0 : 0.0;
        if (r7.w != 0) break;
        r4.w = 0.000833333295 + r4.w;
        r9.xyz = r8.xyz;
        r7.w = r5.w;
        r8.w = r6.w;
        r9.w = 0;
        while (true) {
            r10.x = ((int)r9.w >= 3) ? 1.0 : 0.0;
            if (r10.x != 0) break;
            r7.w = 1 + r7.w;
            r10.x = 2.09439516 * r7.w;
            sincos(r10.x, r10.x, r11.x);
            r11.x = r11.x * r4.w + v0.x;
            r11.y = r10.x * r4.w + v0.y;
            r10.xyz = tex2D(_IN7, r11.xy).xyz;
            r9.xyz = r10.xyz * r4.www + r9.xyz;
            r8.w = r8.w + r4.w;
            r9.w = (int)r9.w + 1;
        }
        r8.xyz = r9.xyz;
        r6.w = r8.w;
        r5.w = 0.620000005 + r7.w;
        r4.z = (int)r4.z + 1;
        }
        r8.xyz = r8.xyz / r6.www;
        r9.xyz = (float3(0.644999981,0.312000006,0.978999972) < r0.xxx) ? 1.0 : 0.0;
        r10.xyz = (r0.xxx < float3(0.685000002,0.351999998,1.02100003)) ? 1.0 : 0.0;
        r9.xyz = r9.xyz ? r10.xyz : 0;
        r0.x = r9.z ? 1.000000 : 0;
        r0.x = r9.y ? 0 : r0.x;
        r0.x = r9.x ? 1 : r0.x;
        r4.z = (int)r9.y | (int)r9.z;
        r4.z = (int)r4.z & 0x3f800000;
        r4.z = r9.x ? 0 : r4.z;
        r3.x = 255 * r3.x;
        r3.x = round(r3.x);
        r3.x = (uint)r3.x;
        r9.xyzw = (int4)r3.xxxx & int4(15,240,240,15);
        r9.xyzw = (uint4)r9.xyzw;
        r3.x = saturate(r0.w + r0.w);
        r4.w = r3.x * -2 + 3;
        r3.x = r3.x * r3.x;
        r3.x = r4.w * r3.x;
        r4.w = -0.5 + r0.w;
        r4.w = saturate(r4.w + r4.w);
        r5.w = r4.w * -2 + 3;
        r4.w = r4.w * r4.w;
        r4.w = r5.w * r4.w;
        r10.xyz = cb1[262].xyz + -cb1[261].xyz;
        r5.w = dot(abs(r10.xyz), float3(0.300000012,0.589999974,0.109999999));
        r5.w = 10 * r5.w;
        r5.w = min(1, r5.w);
        r6.w = r5.w * -2 + 3;
        r5.w = r5.w * r5.w;
        r5.w = r6.w * r5.w;
        r6.w = r5.w * r4.w;
        r7.w = cb1[265].y + -cb1[265].x;
        r8.w = r1.w * cb1[253].y + -cb1[265].x;
        r7.w = 1 / r7.w;
        r8.w = saturate(r8.w * r7.w);
        r10.x = r8.w * -2 + 3;
        r8.w = r8.w * r8.w;
        r8.w = r10.x * r8.w;
        r8.w = r8.w * r6.w;
        r10.x = r1.w * cb1[253].y + -r8.w;
        r8.w = cb1[265].z * r10.x + r8.w;
        r10.x = -cb1[265].x + r8.w;
        r7.w = saturate(r10.x * r7.w);
        r10.x = r7.w * -2 + 3;
        r7.w = r7.w * r7.w;
        r7.w = r10.x * r7.w;
        r6.w = r7.w * r6.w;
        r4.w = r4.w * r5.w + -r6.w;
        r4.w = cb1[265].z * r4.w + r6.w;
        r5.w = -1 + r8.w;
        r5.w = cb1[260].y * r5.w + 1;
        r6.w = r3.w * r4.w + -r5.w;
        r5.w = r5.x * r6.w + r5.w;
        r6.w = r3.w * r4.w + -r4.w;
        r10.x = r5.x * r6.w + r4.w;
        r4.w = (r8.y >= r8.z) ? 1.0 : 0.0;
        r4.w = r4.w ? 1.000000 : 0;
        r11.xy = r8.zy;
        r11.zw = float2(-1,0.666666687);
        r12.xy = -r11.xy + r8.yz;
        r12.zw = float2(1,-1);
        r11.xyzw = r4.wwww * r12.xyzw + r11.xyzw;
        r4.w = (r8.x >= r11.x) ? 1.0 : 0.0;
        r4.w = r4.w ? 1.000000 : 0;
        r12.xyz = r11.xyw;
        r12.w = r8.x;
        r11.xyw = r12.wyx;
        r11.xyzw = r11.xyzw + -r12.xyzw;
        r11.xyzw = r4.wwww * r11.xyzw + r12.xyzw;
        r4.w = min(r11.w, r11.y);
        r4.w = r11.x + -r4.w;
        r6.w = r11.w + -r11.y;
        r7.w = r4.w * 6 + 0.00100000005;
        r6.w = r6.w / r7.w;
        r6.w = r11.z + r6.w;
        r7.w = 0.00100000005 + r11.x;
        r4.w = r4.w / r7.w;
        r7.w = r11.x * 0.300000012 + 1;
        r11.xyzw = r9.xyzw * float4(0.0400000028,0.0027450982,0.00392156886,0.0666666701) + float4(0.400000006,0.400000006,1,0.5);
        r8.w = (r9.z >= 2.54999971) ? 1.0 : 0.0;
        r8.w = r8.w ? 1.000000 : 0;
        r9.x = r11.y + -r11.x;
        r9.x = r8.w * r9.x + r11.x;
        r4.w = r9.x * r4.w;
        r4.w = min(0.349999994, r4.w);
        r9.x = max(0, r4.w);
        r9.yzw = float3(1,0.666666687,0.333333343) + abs(r6.www);
        r9.yzw = frac(r9.yzw);
        r9.yzw = r9.yzw * float3(6,6,6) + float3(-3,-3,-3);
        r9.yzw = saturate(float3(-1,-1,-1) + abs(r9.yzw));
        r9.yzw = float3(-1,-1,-1) + r9.yzw;
        r9.xyz = r9.xxx * r9.yzw + float3(1,1,1);
        r4.w = 1 + r4.w;
        r12.xyz = r9.xyz * r4.www;
        r13.xyz = r9.xyz * r4.www + float3(-1,-1,-1);
        r13.xyz = r13.xyz * float3(0.600000024,0.600000024,0.600000024) + float3(1,1,1);
        r9.xyz = -r9.xyz * r4.www + r13.xyz;
        r9.xyz = r0.xxx * r9.xyz + r12.xyz;
        r12.xyz = r9.xyz + -r2.xyz;
        r12.xyz = r12.xyz * float3(0.850000024,0.850000024,0.850000024) + r2.xyz;
        r11.xyz = r11.zzz * r12.xyz + -r9.xyz;
        r9.xyz = r8.www * r11.xyz + r9.xyz;
        r9.xyz = float3(-1,-1,-1) + r9.xyz;
        r9.xyz = r11.www * r9.xyz + float3(1,1,1);
        r11.xyz = float3(0.200000003,0.200000003,0.200000003) * cb1[261].xyz;
        r12.xyz = cb1[262].xyz * float3(0.5,0.5,0.5) + -r11.xyz;
        r11.xyz = r5.www * r12.xyz + r11.xyz;
        r11.xyz = cb1[260].xxx * r11.xyz;
        r11.xyz = r11.xyz * r2.xyz;
        r12.xyz = r11.xyz * r7.xyz;
        r13.xyz = cb1[261].xyz * r2.xyz;
        r0.x = r3.x * 0.300000012 + 0.699999988;
        r14.xyz = r13.xyz * r0.xxx;
        r15.xyz = cb1[262].xyz * r2.xyz;
        r12.xyz = r13.xyz * r0.xxx + r12.xyz;
        r13.xyz = r2.xyz * cb1[262].xyz + -r14.xyz;
        r13.xyz = r13.xyz * float3(0.400000006,0.400000006,0.400000006) + r14.xyz;
        r16.xyz = r14.xyz * r9.xyz;
        r13.xyz = r13.xyz * r9.xyz + -r16.xyz;
        r13.xyz = r10.xxx * r13.xyz + r16.xyz;
        r11.xyz = r11.xyz * r7.xyz + r13.xyz;
        r12.xyz = r12.xyz * r9.xyz;
        r13.xyz = r15.xyz * r7.www;
        r9.xyz = r13.xyz * r9.xyz + -r12.xyz;
        r9.xyz = r10.xxx * r9.xyz + r12.xyz;
        r0.x = tex2Dlod(_IN8, float4(v0.xy, 0, 0)).x;
        r0.x = -1 + r0.x;
        r0.x = r4.z * r0.x + 1;
        r9.xyz = r9.xyz + -r11.xyz;
        r9.xyz = r5.www * r9.xyz + r11.xyz;
        r11.xyz = float3(1,1,1) + -r8.xyz;
        r8.xyz = r0.xxx * r11.xyz + r8.xyz;
        r8.xyz = r9.xyz * r8.xyz;
    } else {
        r0.x = saturate(r0.w + r0.w);
        r3.x = r0.x * -2 + 3;
        r0.x = r0.x * r0.x;
        r0.x = r3.x * r0.x;
        r3.x = -0.5 + r0.w;
        r3.x = saturate(r3.x + r3.x);
        r4.z = r3.x * -2 + 3;
        r3.x = r3.x * r3.x;
        r3.x = r4.z * r3.x;
        r9.xyz = cb1[262].xyz + -cb1[261].xyz;
        r4.z = dot(abs(r9.xyz), float3(0.300000012,0.589999974,0.109999999));
        r4.z = 10 * r4.z;
        r4.z = min(1, r4.z);
        r4.w = r4.z * -2 + 3;
        r4.z = r4.z * r4.z;
        r4.z = r4.w * r4.z;
        r4.w = r4.z * r3.x;
        r5.w = cb1[265].y + -cb1[265].x;
        r6.w = r1.w * cb1[253].y + -cb1[265].x;
        r5.w = 1 / r5.w;
        r6.w = saturate(r6.w * r5.w);
        r7.w = r6.w * -2 + 3;
        r6.w = r6.w * r6.w;
        r6.w = r7.w * r6.w;
        r6.w = r6.w * r4.w;
        r1.w = r1.w * cb1[253].y + -r6.w;
        r1.w = cb1[265].z * r1.w + r6.w;
        r6.w = -cb1[265].x + r1.w;
        r5.w = saturate(r6.w * r5.w);
        r6.w = r5.w * -2 + 3;
        r5.w = r5.w * r5.w;
        r5.w = r6.w * r5.w;
        r4.w = r5.w * r4.w;
        r3.x = r3.x * r4.z + -r4.w;
        r3.x = cb1[265].z * r3.x + r4.w;
        r4.z = r1.w * r5.y;
        r4.z = 10 * r4.z;
        r1.w = -1 + r1.w;
        r1.w = cb1[260].y * r1.w + 1;
        r4.w = r3.w * r3.x + -r1.w;
        r1.w = r5.x * r4.w + r1.w;
        r4.w = r3.w * r3.x + -r3.x;
        r10.x = r5.x * r4.w + r3.x;
        r5.xyw = float3(0.200000003,0.200000003,0.200000003) * cb1[261].xyz;
        r9.xyz = cb1[262].xyz * float3(0.5,0.5,0.5) + -r5.xyw;
        r5.xyw = r1.www * r9.xyz + r5.xyw;
        r5.xyw = cb1[260].xxx * r5.xyw;
        r5.xyw = r5.xyw * r2.xyz;
        r9.xyz = r5.xyw * r7.xyz;
        r11.xyz = cb1[261].xyz * r2.xyz;
        r0.x = r0.x * 0.300000012 + 0.699999988;
        r14.xyz = r11.xyz * r0.xxx;
        r11.xyz = r11.xyz * r0.xxx + r9.xyz;
        r9.xyz = r9.xyz * r4.zzz + r11.xyz;
        r11.xyz = r2.xyz * cb1[262].xyz + -r14.xyz;
        r11.xyz = r11.xyz * r10.xxx;
        r11.xyz = r11.xyz * float3(0.400000006,0.400000006,0.400000006) + r14.xyz;
        r5.xyw = r5.xyw * r7.xyz + r11.xyz;
        r11.xyz = r2.xyz * cb1[262].xyz + -r9.xyz;
        r9.xyz = r10.xxx * r11.xyz + r9.xyz;
        r9.xyz = r9.xyz + -r5.xyw;
        r8.xyz = r1.www * r9.xyz + r5.xyw;
    }
    r0.x = -0.400000006 + r0.w;
    r0.x = saturate(10.000001 * r0.x);
    r0.w = r0.x * -2 + 3;
    r0.x = r0.x * r0.x;
    r10.y = r0.w * r0.x;
    r5.xyw = r8.xyz * float3(0.5,0.5,0.5) + cb1[261].xyz;
    r5.xyw = r5.xyw * r2.xyz;
    r9.xyz = cb1[261].xyz * r2.xyz;
    r5.xyw = cb1[255].xxx ? r5.xyw : r9.xyz;
    r9.xyz = r0.zzz ? r5.xyw : r14.xyz;
    r5.xyw = r0.zzz ? r5.xyw : r8.xyz;
    r0.xw = r0.zz ? float2(0,0) : r10.xy;
    r8.xyz = cb1[264].xyz + cb1[264].xyz;
    r8.xyz = r0.xxx * r8.xyz + -cb1[264].xyz;
    r10.xyz = float3(0,0,0);
    r1.w = 1;
    r3.x = 0;
    while (true) {
        r4.z = ((uint)r3.x >= asuint(cb2[128].x)) ? 1.0 : 0.0;
        if (r4.z != 0) break;
        bitmask.z = ((~(-1 << 29)) << 3) & 0xffffffff;  r4.z = (((uint)r3.x << 3) & bitmask.z) | ((uint)7 & ~bitmask.z);
        bitmask.w = ((~(-1 << 3)) << 5) & 0xffffffff;  r4.w = (((uint)cb2[r4.z+0].w << 5) & bitmask.w) | ((uint)0 & ~bitmask.w);
        r4.w = (int)r4.y & (int)r4.w;
        if (r4.w == 0) {
        r4.w = (int)r3.x + 1;
        r3.x = r4.w;
        continue;
        }
        r4.w = (uint)r3.x << 3;
        r11.xyz = cb2[r4.w+0].xyz + -r6.xyz;
        r6.w = cb2[r4.w+0].w * cb2[r4.w+0].w;
        r7.w = dot(r11.xyz, r11.xyz);
        r6.w = r7.w * r6.w;
        r8.w = (1 >= r6.w) ? 1.0 : 0.0;
        if (r8.w != 0) {
        bitmask.x = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.x = (((uint)r3.x << 3) & bitmask.x) | ((uint)1 & ~bitmask.x);
        bitmask.y = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.y = (((uint)r3.x << 3) & bitmask.y) | ((uint)2 & ~bitmask.y);
        bitmask.z = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.z = (((uint)r3.x << 3) & bitmask.z) | ((uint)3 & ~bitmask.z);
        bitmask.w = ((~(-1 << 29)) << 3) & 0xffffffff;  r12.w = (((uint)r3.x << 3) & bitmask.w) | ((uint)4 & ~bitmask.w);
        bitmask.x = ((~(-1 << 29)) << 3) & 0xffffffff;  r13.x = (((uint)r3.x << 3) & bitmask.x) | ((uint)5 & ~bitmask.x);
        bitmask.y = ((~(-1 << 29)) << 3) & 0xffffffff;  r13.y = (((uint)r3.x << 3) & bitmask.y) | ((uint)6 & ~bitmask.y);
        r6.w = saturate(r6.w * 2.5 + -1.5);
        r8.w = r6.w * r6.w;
        r6.w = -r6.w * 2 + 3;
        r6.w = -r8.w * r6.w + 1;
        r7.w = rsqrt(r7.w);
        r14.xyz = r11.xyz * r7.www;
        r7.w = dot(r1.xyz, r14.xyz);
        r7.w = 1 + r7.w;
        r13.zw = cb2[r13.x+0].ww * float2(0.939999998,0.0600000024);
        r7.w = r7.w * 0.5 + -r13.z;
        r8.w = 1 / r13.w;
        r7.w = saturate(r8.w * r7.w);
        r8.w = r7.w * -2 + 3;
        r7.w = r7.w * r7.w;
        r7.w = r8.w * r7.w;
        r7.w = min(1, r7.w);
        r15.xyz = cb2[r13.y+0].xyz * r9.xyz;
        r13.xzw = r2.xyz * cb2[r13.x+0].xyz + -r15.xyz;
        r13.xzw = r7.www * r13.xzw + r15.xyz;
        r13.xzw = cb2[r4.z+0].xxx * r13.xzw;
        r11.xyz = cb2[r4.w+0].www * r11.xyz;
        r4.w = dot(r11.xyz, r11.xyz);
        r4.w = r4.w * cb2[r12.w+0].x + cb2[r12.w+0].y;
        r4.w = 9.99999975e-005 + r4.w;
        r4.w = 1 / r4.w;
        r4.w = -1 + r4.w;
        r4.w = cb2[r12.w+0].z * r4.w;
        r4.w = r4.w * r4.w;
        r4.w = min(1, r4.w);
        if (4 == 0) r7.w = 0; else if (4+16 < 32) {       r7.w = (uint)cb2[r12.x+0].w << (32-(4 + 16)); r7.w = (uint)r7.w >> (32-4);      } else r7.w = (uint)cb2[r12.x+0].w >> 16;
        r7.w = ((int)r7.w == 2) ? 1.0 : 0.0;
        r8.w = dot(r14.xyz, cb2[r12.x+0].xyz);
        r8.w = -cb2[r12.y+0].x + r8.w;
        r8.w = saturate(cb2[r12.y+0].y * r8.w);
        r8.w = r8.w * r8.w;
        r8.w = r8.w * r8.w;
        r8.w = r8.w * r4.w;
        r4.w = r7.w ? r8.w : r4.w;
        r7.w = dot(r8.xyz, r14.xyz);
        r7.w = saturate(r7.w * 0.5 + 0.5);
        r7.w = r0.w * r7.w + -r0.x;
        r7.w = cb2[r12.w+0].w * r7.w + r0.x;
        r11.xyz = cb2[r12.z+0].www * r9.xyz;
        r12.xyw = -r9.xyz * cb2[r12.z+0].www + r2.xyz;
        r11.xyz = r7.www * r12.xyw + r11.xyz;
        r11.xyz = cb2[r12.z+0].xyz * r11.xyz;
        r7.w = cb2[r12.z+0].x + cb2[r12.z+0].y;
        r7.w = cb2[r12.z+0].z + r7.w;
        r7.w = cb2[r4.z+0].x + r7.w;
        r7.w = saturate(10 * r7.w);
        r4.z = cb2[r4.z+0].y * r7.w;
        r12.xyz = r13.xzw * r4.www;
        r11.xyz = r11.xyz * r4.www + r12.xyz;
        r6.w = r6.w + -r4.w;
        r4.w = cb2[r13.y+0].w * r6.w + r4.w;
        r10.xyz = r11.xyz * r1.www + r10.xyz;
        r4.z = -r4.w * r4.z + 1;
        r1.w = r4.z * r1.w;
        }
        r3.x = (int)r3.x + 1;
    }
    r4.yzw = r1.www * r5.xyw + r10.xyz;
    r0.x = ((int)r4.x != 13) ? 1.0 : 0.0;
    if (r0.x != 0) {
        r0.x = ((int)r4.x == 1) ? 1.0 : 0.0;
        r0.x = r0.x ? r3.z : r3.y;
        r3.xyz = cb1[67].xyz + -r6.xyz;
        r0.w = dot(r3.xyz, r3.xyz);
        r0.w = rsqrt(r0.w);
        r3.xyz = r3.xyz * r0.www;
        r0.w = saturate(-0.100000001 + r0.x);
        r0.x = saturate(10 * r0.x);
        r1.w = r0.w * 2000 + 50;
        r4.x = r0.w + r0.w;
        r0.x = cb0[0].x * r0.x;
        r0.x = r0.x * 0.800000012 + r4.x;
        r5.xyw = cb1[21].xyz * r1.yyy;
        r5.xyw = r1.xxx * cb1[20].xyz + r5.xyw;
        r5.xyw = r1.zzz * cb1[22].xyz + r5.xyw;
        r4.x = asint(cb0[0].w);
        r4.x = (0.5 < r4.x) ? 1.0 : 0.0;
        r3.xyz = r4.xxx ? float3(0,0,0) : r3.xyz;
        r6.xy = r4.xx ? cb0[0].yz : cb1[264].xy;
        r6.z = r4.x ? 0.5 : cb1[264].z;
        r1.xyz = r4.xxx ? r5.xyw : r1.xyz;
        r4.x = dot(r6.xyz, r1.xyz);
        r8.xy = float2(0.200000003,1) + r4.xx;
        r4.x = 5 * r8.x;
        r4.x = saturate(r4.x);
        r5.w = r4.x * -2 + 3;
        r4.x = r4.x * r4.x;
        r4.x = r5.w * r4.x;
        r8.xzw = r6.xyz + r3.xyz;
        r5.w = dot(r8.xzw, r8.xzw);
        r5.w = rsqrt(r5.w);
        r8.xzw = r8.xzw * r5.www;
        r5.w = saturate(dot(r1.xyz, r8.xzw));
        r5.w = r5.w * r5.w;
        r5.w = r5.w * -0.800000012 + 1;
        r5.w = r5.w * r5.w;
        r5.w = 3.14159274 * r5.w;
        r5.w = 0.200000003 / r5.w;
        r5.w = r5.w * r3.w;
        r6.x = dot(r6.xyz, r3.xyz);
        r6.xy = float2(-0.5,1) + -r6.xx;
        r6.x = saturate(r6.x + r6.x);
        r6.z = r6.x * -2 + 3;
        r6.x = r6.x * r6.x;
        r6.x = r6.z * r6.x + 1;
        r1.x = saturate(dot(r3.xyz, r1.xyz));
        r1.x = 0.800000012 + -r1.x;
        r1.x = max(0, r1.x);
        r1.y = max(0, cb1[133].x);
        r1.y = min(1.74532926, r1.y);
        r1.xy = float2(1.5,0.572957814) * r1.xy;
        r1.z = max(0, r2.w);
        r3.xy = min(float2(3000,50), r1.zz);
        r3.xy = float2(3000,50) + -r3.xy;
        r3.xy = float2(0.00033333333,0.0199999996) * r3.xy;
        r1.z = r3.x * r3.x;
        r1.z = r1.z * r1.z;
        r1.z = r1.z * r1.z + r3.y;
        r1.z = -1 + r1.z;
        r1.y = r1.y * r1.z + 1;
        r1.z = 1 + -r1.y;
        r1.y = r0.w * r1.z + r1.y;
        r1.z = r8.y * 0.25 + 0.5;
        r1.x = r1.z * r1.x;
        r1.x = r1.x * r1.y;
        r1.x = r1.x * r6.x;
        r1.x = 0.00999999978 * r1.x;
        r3.xy = float2(9.99999975e-005,9.99999975e-005) + r5.xy;
        r1.z = dot(r3.xy, r3.xy);
        r1.z = rsqrt(r1.z);
        r3.xy = r3.xy * r1.zz;
        r3.xy = r3.xy * r0.xx;
        r3.z = r3.y * r1.x;
        r1.y = -0.5;
        r1.xy = r3.xz * r1.xy;
        r0.x = 0.400000006 * r6.y;
        r1.z = r4.x * 0.800000012 + 0.200000003;
        r3.x = r5.w * r4.x;
        r3.x = 1.5 * r3.x;
        r0.x = r0.x * r1.z + r3.x;
        r1.z = r3.w * 0.5 + 0.5;
        r0.x = r1.z * r0.x;
        r3.xy = v0.xy * cb1[138].xy + -cb1[134].xy;
        r1.xy = r3.xy * cb1[135].zw + r1.xy;
        r1.xy = r1.xy * cb1[135].xy + cb1[134].xy;
        r1.xy = cb1[138].zw * r1.xy;
        r1.x = tex2D(_IN6, r1.xy).x;
        r1.y = r1.x * cb1[65].x + cb1[65].y;
        r1.x = r1.x * cb1[65].z + -cb1[65].w;
        r1.x = 1 / r1.x;
        r1.x = r1.y + r1.x;
        r1.x = r1.x + -r2.w;
        r1.x = max(9.99999975e-005, r1.x);
        r0.w = -r0.w * 1000 + r1.x;
        r1.x = 1 / r1.w;
        r0.w = saturate(r1.x * r0.w);
        r1.x = r0.w * -2 + 3;
        r0.w = r0.w * r0.w;
        r0.w = r1.x * r0.w;
        r0.w = min(1, r0.w);
        r1.x = dot(cb1[263].xyz, float3(0.300000012,0.589999974,0.109999999));
        r1.yzw = cb1[263].xyz + -r1.xxx;
        r1.xyz = r1.yzw * float3(0.75,0.75,0.75) + r1.xxx;
        r3.xyz = cb1[263].xyz + -r1.xyz;
        r1.xyz = r3.www * r3.xyz + r1.xyz;
        r1.xyz = r1.xyz * r0.xxx;
        r1.xyz = float3(0.100000001,0.100000001,0.100000001) * r1.xyz;
        r3.xyz = float3(1,1,1) + r2.xyz;
        r3.xyz = r3.xyz * r1.xyz;
        r5.xyw = r2.xyz * float3(1.20000005,1.20000005,1.20000005) + float3(-1,-1,-1);
        r5.xyw = saturate(-r5.xyw);
        r6.xyz = r5.xyw * float3(-2,-2,-2) + float3(3,3,3);
        r5.xyw = r5.xyw * r5.xyw;
        r5.xyw = r6.xyz * r5.xyw;
        r5.xyw = r5.xyw * float3(14,14,14) + float3(1,1,1);
        r1.xyz = r5.xyw * r1.xyz;
        r1.xyz = r1.xyz * r2.xyz + -r3.xyz;
        r1.xyz = cb1[260].zzz * r1.xyz + r3.xyz;
        r1.xyz = r1.xyz * r0.www;
        r0.x = -10000 + r2.w;
        r0.x = max(0, r0.x);
        r0.x = min(5000, r0.x);
        r0.x = 5000 + -r0.x;
        r0.x = 0.000199999995 * r0.x;
        r1.xyz = r0.xxx * r1.xyz;
        r1.xyz = cb0[1].xyz * r1.xyz;
    } else {
        r1.xyz = float3(0,0,0);
    }
    r0.x = (0 != r5.z) ? 1.0 : 0.0;
    r2.xyz = r4.yzw * r7.xyz;
    r2.xyz = cb1[263].xyz * r2.xyz;
    r2.xyz = r2.xyz * float3(0.5,0.5,0.5) + -r4.yzw;
    r2.xyz = r0.www * r2.xyz + r4.yzw;
    r1.xyz = r4.yzw + r1.xyz;
    r1.xyz = r0.xxx ? r2.xyz : r1.xyz;
    r0.xzw = r0.zzz ? r4.yzw : r1.xyz;
    r0.xyz = r0.xzw / r0.yyy;
    r0.xyz = min(float3(0,0,0), -r0.xyz);
    color.xyz = -r0.xyz;
    return color;
}